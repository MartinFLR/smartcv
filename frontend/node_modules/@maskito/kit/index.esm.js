import { maskitoUpdateElement, MASKITO_DEFAULT_OPTIONS, maskitoTransform } from '@maskito/core';

/**
 * Clamps a value between two inclusive limits
 *
 * @param value
 * @param min lower limit
 * @param max upper limit
 */
function clamp(value, min, max) {
    const clampedValue = Math.min(Number(max), Math.max(Number(min), Number(value)));
    return (value instanceof Date ? new Date(clampedValue) : clampedValue);
}

function countDigits(str) {
    return str.replaceAll(/\W/g, '').length;
}

const DATE_SEGMENTS_MAX_VALUES = {
    day: 31,
    month: 12,
    year: 9999,
};

// eslint-disable-next-line i18n/no-russian-character
const DEFAULT_DECIMAL_PSEUDO_SEPARATORS = ['.', ',', 'б', 'ю'];

const DEFAULT_MIN_DATE = new Date('0001-01-01T00:00');
const DEFAULT_MAX_DATE = new Date('9999-12-31T23:59:59.999');

/**
 * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.
 */
const CHAR_NO_BREAK_SPACE = '\u00A0';
/**
 * {@link https://symbl.cc/en/200B/ Zero width space}.
 */
const CHAR_ZERO_WIDTH_SPACE = '\u200B';
/**
 * {@link https://unicode-table.com/en/2013/ EN dash}
 * is used to indicate a range of numbers or a span of time.
 * @example 2006–2022
 */
const CHAR_EN_DASH = '\u2013';
/**
 * {@link https://unicode-table.com/en/2014/ EM dash}
 * is used to mark a break in a sentence.
 * @example Taiga UI — powerful set of open source components for Angular
 * ___
 * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_HYPHEN}!
 */
const CHAR_EM_DASH = '\u2014';
/**
 * {@link https://unicode-table.com/en/002D/ Hyphen (minus sign)}
 * is used to combine words.
 * @example well-behaved
 * ___
 * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_EM_DASH}!
 */
const CHAR_HYPHEN = '\u002D';
/**
 * {@link https://unicode-table.com/en/2212/ Minus}
 * is used as math operator symbol or before negative digits.
 * ---
 * Can be used as `&minus;`. Don't confuse with {@link CHAR_HYPHEN}
 */
const CHAR_MINUS = '\u2212';
/**
 * {@link https://symbl.cc/en/30FC/ Katakana-Hiragana Prolonged Sound Mark}
 * is used as prolonged sounds in Japanese.
 */
const CHAR_JP_HYPHEN = '\u30FC';
/**
 * {@link https://symbl.cc/en/003A/ Colon}
 * is a punctuation mark that connects parts of a text logically.
 * ---
 * is also used as separator in time.
 */
const CHAR_COLON = '\u003A';
/**
 * {@link https://symbl.cc/en/FF1A/ Full-width colon}
 * is a full-width punctuation mark used to separate parts of a text commonly in Japanese.
 */
const CHAR_JP_COLON = '\uFF1A';

const DEFAULT_PSEUDO_MINUSES = [
    CHAR_HYPHEN,
    CHAR_EN_DASH,
    CHAR_EM_DASH,
    CHAR_JP_HYPHEN,
    CHAR_MINUS,
];

const DEFAULT_TIME_SEGMENT_MAX_VALUES = {
    hours: 23,
    minutes: 59,
    seconds: 59,
    milliseconds: 999,
};
const DEFAULT_TIME_SEGMENT_MIN_VALUES = {
    hours: 0,
    minutes: 0,
    seconds: 0,
    milliseconds: 0,
};

const ANY_MERIDIEM_CHARACTER_RE = new RegExp(`[${CHAR_NO_BREAK_SPACE}APM]+$`, 'g');
const ALL_MERIDIEM_CHARACTERS_RE = new RegExp(`${CHAR_NO_BREAK_SPACE}[AP]M$`, 'g');

const TIME_FIXED_CHARACTERS = [':', '.'];

const TIME_SEGMENT_VALUE_LENGTHS = {
    hours: 2,
    minutes: 2,
    seconds: 2,
    milliseconds: 3,
};

const POSSIBLE_DATE_RANGE_SEPARATOR = [
    CHAR_HYPHEN,
    CHAR_EN_DASH,
    CHAR_EM_DASH,
    CHAR_MINUS,
    CHAR_JP_HYPHEN,
];
const MIN_DAY = 1;
const MONTHS_IN_YEAR = 12;
const MonthNumber = {
    January: 0,
    February: 1,
    April: 3,
    June: 5,
    September: 8,
    November: 10,
    December: 11,
};

function appendDate(date, { day = 0, month = 0, year = 0 } = {}) {
    if (day === 0 && month === 0 && year === 0) {
        return date;
    }
    const initialYear = date.getFullYear();
    const initialMonth = date.getMonth();
    const initialDate = date.getDate();
    const totalMonths = (initialYear + year) * MONTHS_IN_YEAR + initialMonth + month;
    let years = Math.floor(totalMonths / MONTHS_IN_YEAR);
    let months = totalMonths % MONTHS_IN_YEAR;
    let days = Math.min(initialDate, getMonthDaysCount(months, isLeapYear(years))) + day;
    while (days > getMonthDaysCount(months, isLeapYear(years))) {
        days -= getMonthDaysCount(months, isLeapYear(years));
        if (months === MonthNumber.December) {
            years++;
            months = MonthNumber.January;
        }
        else {
            months++;
        }
    }
    while (days < MIN_DAY) {
        if (months === MonthNumber.January) {
            years--;
            months = MonthNumber.December;
        }
        else {
            months--;
        }
        days += getMonthDaysCount(months, isLeapYear(years));
    }
    days =
        day < 0 || (day === 0 && isLeapYear(initialYear) && (month < 0 || year < 0))
            ? days + 1 // add one day when moving days backward, or months or years backward for leap year
            : days - 1; // "from"-day is included in the range
    return new Date(years, months, days);
}
function getMonthDaysCount(month, isLeapYear) {
    switch (month) {
        case MonthNumber.April:
        case MonthNumber.June:
        case MonthNumber.November:
        case MonthNumber.September:
            return 30;
        case MonthNumber.February:
            return isLeapYear ? 29 : 28;
        default:
            return 31;
    }
}
function isLeapYear(year) {
    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

const getDateSegmentValueLength = (dateString) => {
    var _a, _b, _c, _d, _e, _f;
    return ({
        day: (_b = (_a = dateString.match(/d/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,
        month: (_d = (_c = dateString.match(/m/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,
        year: (_f = (_e = dateString.match(/y/g)) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0,
    });
};

function dateToSegments(date) {
    return {
        day: String(date.getDate()).padStart(2, '0'),
        month: String(date.getMonth() + 1).padStart(2, '0'),
        year: String(date.getFullYear()).padStart(4, '0'),
        hours: String(date.getHours()).padStart(2, '0'),
        minutes: String(date.getMinutes()).padStart(2, '0'),
        seconds: String(date.getSeconds()).padStart(2, '0'),
        milliseconds: String(date.getMilliseconds()).padStart(3, '0'),
    };
}

const ALL_POSSIBLE_SEGMENTS = [
    'day',
    'month',
    'year',
];
function getDateSegmentsOrder(template) {
    return [...ALL_POSSIBLE_SEGMENTS].sort((a, b) => template.indexOf(a[0]) > template.indexOf(b[0]) ? 1 : -1);
}

function getFirstCompleteDate(dateString, dateModeTemplate) {
    const digitsInDate = countDigits(dateModeTemplate);
    const [completeDate = ''] = new RegExp(`(\\D*\\d){${digitsInDate}}`).exec(dateString) || [];
    return completeDate;
}

function isDateStringComplete(dateString, dateModeTemplate) {
    if (dateString.length < dateModeTemplate.length) {
        return false;
    }
    return dateString.split(/\D/).every((segment) => !/^0+$/.exec(segment));
}

function parseDateRangeString(dateRange, dateModeTemplate, rangeSeparator) {
    const digitsInDate = countDigits(dateModeTemplate);
    return (dateRange
        .replace(rangeSeparator, '')
        .match(new RegExp(`(\\D*\\d[^\\d\\s]*){1,${digitsInDate}}`, 'g')) || []);
}

function parseDateString(dateString, fullMode) {
    const cleanMode = fullMode.replaceAll(/[^dmy]/g, '');
    const onlyDigitsDate = dateString.replaceAll(/\D+/g, '');
    const dateSegments = {
        day: onlyDigitsDate.slice(cleanMode.indexOf('d'), cleanMode.lastIndexOf('d') + 1),
        month: onlyDigitsDate.slice(cleanMode.indexOf('m'), cleanMode.lastIndexOf('m') + 1),
        year: onlyDigitsDate.slice(cleanMode.indexOf('y'), cleanMode.lastIndexOf('y') + 1),
    };
    return Object.fromEntries(Object.entries(dateSegments)
        .filter(([_, value]) => Boolean(value))
        .sort(([a], [b]) => fullMode.toLowerCase().indexOf(a.slice(0, 1)) >
        fullMode.toLowerCase().indexOf(b.slice(0, 1))
        ? 1
        : -1));
}

function segmentsToDate(parsedDate, parsedTime) {
    var _a, _b, _c, _d, _e, _f, _g;
    const year = ((_a = parsedDate.year) === null || _a === void 0 ? void 0 : _a.length) === 2 ? `20${parsedDate.year}` : parsedDate.year;
    const date = new Date(Number(year !== null && year !== void 0 ? year : '0'), Number((_b = parsedDate.month) !== null && _b !== void 0 ? _b : '1') - 1, Number((_c = parsedDate.day) !== null && _c !== void 0 ? _c : '1'), Number((_d = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.hours) !== null && _d !== void 0 ? _d : '0'), Number((_e = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.minutes) !== null && _e !== void 0 ? _e : '0'), Number((_f = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.seconds) !== null && _f !== void 0 ? _f : '0'), Number((_g = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.milliseconds) !== null && _g !== void 0 ? _g : '0'));
    // needed for years less than 1900
    date.setFullYear(Number(year !== null && year !== void 0 ? year : '0'));
    return date;
}

const DATE_TIME_SEPARATOR = ', ';

function toDateString({ day, month, year, hours, minutes, seconds, milliseconds, }, { dateMode, dateTimeSeparator = DATE_TIME_SEPARATOR, timeMode, }) {
    var _a;
    const safeYear = ((_a = dateMode.match(/y/g)) === null || _a === void 0 ? void 0 : _a.length) === 2 ? year === null || year === void 0 ? void 0 : year.slice(-2) : year;
    const fullMode = dateMode + (timeMode ? dateTimeSeparator + timeMode : '');
    return fullMode
        .replaceAll(/d+/g, day !== null && day !== void 0 ? day : '')
        .replaceAll(/m+/g, month !== null && month !== void 0 ? month : '')
        .replaceAll(/y+/g, safeYear !== null && safeYear !== void 0 ? safeYear : '')
        .replaceAll(/H+/g, hours !== null && hours !== void 0 ? hours : '')
        .replaceAll('MSS', milliseconds !== null && milliseconds !== void 0 ? milliseconds : '')
        .replaceAll(/M+/g, minutes !== null && minutes !== void 0 ? minutes : '')
        .replaceAll(/S+/g, seconds !== null && seconds !== void 0 ? seconds : '')
        .replaceAll(/^\D+/g, '')
        .replaceAll(/\D+$/g, '');
}

function validateDateString({ dateString, dateModeTemplate, dateSegmentsSeparator, offset, selection: [from, to], }) {
    var _a, _b;
    const parsedDate = parseDateString(dateString, dateModeTemplate);
    const dateSegments = Object.entries(parsedDate);
    const segmentsOrder = getDateSegmentsOrder(dateModeTemplate);
    const validatedDateSegments = {};
    for (let i = 0; i < dateSegments.length; i++) {
        const [segmentName, segmentValue] = dateSegments[i];
        const validatedDate = toDateString(validatedDateSegments, {
            dateMode: dateModeTemplate,
        });
        const maxSegmentValue = DATE_SEGMENTS_MAX_VALUES[segmentName];
        const fantomSeparator = validatedDate.length && dateSegmentsSeparator.length;
        const lastSegmentDigitIndex = offset +
            validatedDate.length +
            fantomSeparator +
            getDateSegmentValueLength(dateModeTemplate)[segmentName];
        const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex === to;
        if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {
            const nextSegment = segmentsOrder[segmentsOrder.indexOf(segmentName) + 1];
            if (!nextSegment || nextSegment === 'year') {
                // 31.1|0.2010 => Type 9 => 31.1|0.2010
                return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes
            }
            validatedDateSegments[segmentName] = `0${segmentValue.slice(0, -1)}`;
            dateSegments[i + 1] = [
                nextSegment,
                segmentValue.slice(-1) + ((_b = (_a = dateSegments[i + 1]) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '').slice(1),
            ];
            continue;
        }
        if (isLastSegmentDigitAdded && Number(segmentValue) < 1) {
            // 31.0|1.2010 => Type 0 => 31.0|1.2010
            return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes
        }
        validatedDateSegments[segmentName] = segmentValue;
    }
    const validatedDateString = toDateString(validatedDateSegments, {
        dateMode: dateModeTemplate,
    });
    const addedDateSegmentSeparators = validatedDateString.length - dateString.length;
    return {
        validatedDateString,
        updatedSelection: [
            from + addedDateSegmentSeparators,
            to + addedDateSegmentSeparators,
        ],
    };
}

function identity(x) {
    return x;
}
// eslint-disable-next-line  @typescript-eslint/no-empty-function
function noop() { }

/**
 * Copy-pasted solution from lodash
 * @see https://lodash.com/docs/4.17.15#escapeRegExp
 */
const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
const reHasRegExpChar = new RegExp(reRegExpChar.source);
function escapeRegExp(str) {
    return str && reHasRegExpChar.test(str)
        ? str.replaceAll(reRegExpChar, String.raw `\$&`)
        : str;
}

function findCommonBeginningSubstr(a, b) {
    let res = '';
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return res;
        }
        res += a[i];
    }
    return res;
}

function isEmpty(entity) {
    return !entity || (typeof entity === 'object' && Object.keys(entity).length === 0);
}

const ALL_ZEROES_RE = /^0+$/;
function padWithZeroesUntilValid(segmentValue, paddedMaxValue, prefixedZeroesCount = 0) {
    const paddedSegmentValue = segmentValue.padEnd(paddedMaxValue.length, '0');
    if (Number(paddedSegmentValue) <= Number(paddedMaxValue)) {
        return { validatedSegmentValue: segmentValue, prefixedZeroesCount };
    }
    if (paddedSegmentValue.endsWith('0')) {
        // 00:|00 => Type 9 => 00:09|
        return padWithZeroesUntilValid(`0${segmentValue.slice(0, paddedMaxValue.length - 1)}`, paddedMaxValue, prefixedZeroesCount + 1);
    }
    const valueWithoutLastChar = segmentValue.slice(0, paddedMaxValue.length - 1);
    if (ALL_ZEROES_RE.exec(valueWithoutLastChar)) {
        return { validatedSegmentValue: '', prefixedZeroesCount };
    }
    // |19:00 => Type 2 => 2|0:00
    return padWithZeroesUntilValid(`${valueWithoutLastChar}0`, paddedMaxValue, prefixedZeroesCount);
}

/**
 * Replace fullwidth colon with half width colon
 * @param fullWidthColon full width colon
 * @returns processed half width colon
 */
function toHalfWidthColon(fullWidthColon) {
    return fullWidthColon.replaceAll(new RegExp(CHAR_JP_COLON, 'g'), CHAR_COLON);
}

/**
 * Replace fullwidth numbers with half width number
 * @param fullWidthNumber full width number
 * @returns processed half width number
 */
function toHalfWidthNumber(fullWidthNumber) {
    return fullWidthNumber.replaceAll(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xfee0));
}

/**
 * Convert full width colon (：) to half width one (:)
 */
function createColonConvertPreprocessor() {
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        return {
            elementState: {
                selection,
                value: toHalfWidthColon(value),
            },
            data: toHalfWidthColon(data),
        };
    };
}

function createDateSegmentsZeroPaddingPostprocessor({ dateModeTemplate, dateSegmentSeparator, splitFn, uniteFn, }) {
    return ({ value, selection }) => {
        var _a;
        const [from, to] = selection;
        const { dateStrings, restPart = '' } = splitFn(value);
        const validatedDateStrings = [];
        let caretShift = 0;
        dateStrings.forEach((dateString) => {
            const parsedDate = parseDateString(dateString, dateModeTemplate);
            const dateSegments = Object.entries(parsedDate);
            const validatedDateSegments = dateSegments.reduce((acc, [segmentName, segmentValue]) => {
                const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, `${DATE_SEGMENTS_MAX_VALUES[segmentName]}`);
                caretShift += prefixedZeroesCount;
                return Object.assign(Object.assign({}, acc), { [segmentName]: validatedSegmentValue });
            }, {});
            validatedDateStrings.push(toDateString(validatedDateSegments, { dateMode: dateModeTemplate }));
        });
        const validatedValue = uniteFn(validatedDateStrings, value) +
            (((_a = dateStrings[dateStrings.length - 1]) === null || _a === void 0 ? void 0 : _a.endsWith(dateSegmentSeparator))
                ? dateSegmentSeparator
                : '') +
            restPart;
        if (caretShift &&
            validatedValue.slice(to + caretShift, to + caretShift + dateSegmentSeparator.length) === dateSegmentSeparator) {
            /**
             * If `caretShift` > 0, it means that time segment was padded with zero.
             * It is only possible if any character insertion happens.
             * If caret is before `dateSegmentSeparator` => it should be moved after `dateSegmentSeparator`.
             */
            caretShift += dateSegmentSeparator.length;
        }
        return {
            selection: [from + caretShift, to + caretShift],
            value: validatedValue,
        };
    };
}

/**
 * It replaces pseudo range separators with valid one.
 * @example '01.01.2000_11.11.2000' -> '01.01.2000 - 01.01.2000'
 * @example '01.01.2000_23:59' -> '01.01.2000, 23:59'
 */
function createFirstDateEndSeparatorPreprocessor({ dateModeTemplate, firstDateEndSeparator, dateSegmentSeparator, pseudoFirstDateEndSeparators, }) {
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        const [from, to] = selection;
        const firstCompleteDate = getFirstCompleteDate(value, dateModeTemplate);
        const pseudoSeparators = pseudoFirstDateEndSeparators.filter((x) => !firstDateEndSeparator.includes(x) && x !== dateSegmentSeparator);
        const pseudoSeparatorsRE = new RegExp(`[${pseudoSeparators.join('')}]`, 'gi');
        const newValue = firstCompleteDate && value.length > firstCompleteDate.length
            ? firstCompleteDate +
                value
                    .slice(firstCompleteDate.length)
                    .replace(/^[\D\s]*/, firstDateEndSeparator)
            : value;
        const caretShift = newValue.length - value.length;
        return {
            elementState: {
                selection: [from + caretShift, to + caretShift],
                value: newValue,
            },
            data: data.replace(pseudoSeparatorsRE, firstDateEndSeparator),
        };
    };
}

/**
 * Convert full width numbers like １, ２ to half width numbers 1, 2
 */
function createFullWidthToHalfWidthPreprocessor() {
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        return {
            elementState: {
                selection,
                value: toHalfWidthNumber(value),
            },
            data: toHalfWidthNumber(data),
        };
    };
}

function createTimeMaskExpression(mode) {
    return Array.from(mode.replace(' AA', ''))
        .map((char) => (TIME_FIXED_CHARACTERS.includes(char) ? char : /\d/))
        .concat(mode.includes('AA') ? [CHAR_NO_BREAK_SPACE, /[AP]/i, /M/i] : []);
}

function padTimeSegments(timeSegments, pad) {
    return Object.fromEntries(Object.entries(timeSegments).map(([segmentName, segmentValue]) => [
        segmentName,
        pad(String(segmentValue), TIME_SEGMENT_VALUE_LENGTHS[segmentName]),
    ]));
}

function padStartTimeSegments(timeSegments) {
    return padTimeSegments(timeSegments, (value, length) => value.padStart(length, '0'));
}

const SEGMENT_FULL_NAME = {
    HH: 'hours',
    MM: 'minutes',
    SS: 'seconds',
    MSS: 'milliseconds',
};
/**
 * @param timeString can be with/without fixed characters
 */
function parseTimeString(timeString, timeMode) {
    const onlyDigits = timeString.replaceAll(/\D+/g, '');
    let offset = 0;
    return Object.fromEntries(timeMode
        .split(/\W/)
        .filter((segmentAbbr) => SEGMENT_FULL_NAME[segmentAbbr])
        .map((segmentAbbr) => {
        const segmentValue = onlyDigits.slice(offset, offset + segmentAbbr.length);
        offset += segmentAbbr.length;
        return [SEGMENT_FULL_NAME[segmentAbbr], segmentValue];
    }));
}

const LEADING_NON_DIGITS = /^\D*/;
const TRAILING_NON_DIGITS = /\D*$/;
function toTimeString({ hours = '', minutes = '', seconds = '', milliseconds = '', }) {
    return `${hours}:${minutes}:${seconds}.${milliseconds}`
        .replace(LEADING_NON_DIGITS, '')
        .replace(TRAILING_NON_DIGITS, '');
}

const TRAILING_TIME_SEGMENT_SEPARATOR_REG = new RegExp(`[${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]$`);
/**
 * Pads invalid time segment with zero to make it valid.
 * @example 00:|00 => Type 9 (too much for the first digit of minutes) => 00:09|
 * @example |19:00 => Type 2 (29 - invalid value for hours) => 2|0:00
 */
function enrichTimeSegmentsWithZeroes({ value, selection }, { mode, timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES, }) {
    const [from, to] = selection;
    const parsedTime = parseTimeString(value, mode);
    const possibleTimeSegments = Object.entries(parsedTime);
    const paddedMaxValues = padStartTimeSegments(timeSegmentMaxValues);
    const validatedTimeSegments = {};
    let paddedZeroes = 0;
    for (const [segmentName, segmentValue] of possibleTimeSegments) {
        const maxSegmentValue = paddedMaxValues[segmentName];
        const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, String(maxSegmentValue));
        paddedZeroes += prefixedZeroesCount;
        validatedTimeSegments[segmentName] = validatedSegmentValue;
    }
    const [leadingNonDigitCharacters = ''] = value.match(/^\D+(?=\d)/g) || []; // prefix
    const [trailingNonDigitCharacters = ''] = value.match(/\D+$/g) || []; // trailing segment separators / meridiem characters / postfix
    const validatedTimeString = leadingNonDigitCharacters +
        toTimeString(validatedTimeSegments) +
        trailingNonDigitCharacters;
    const addedDateSegmentSeparators = Math.max(validatedTimeString.length - value.length - paddedZeroes, 0);
    let newFrom = from + paddedZeroes + addedDateSegmentSeparators;
    let newTo = to + paddedZeroes + addedDateSegmentSeparators;
    if (newFrom === newTo &&
        paddedZeroes &&
        // if next character after cursor is time segment separator
        validatedTimeString.slice(0, newTo + 1).match(TRAILING_TIME_SEGMENT_SEPARATOR_REG)) {
        newFrom++;
        newTo++;
    }
    return {
        value: validatedTimeString,
        selection: [newFrom, newTo],
    };
}

function padEndTimeSegments(timeSegments) {
    return padTimeSegments(timeSegments, (value, length) => value.padEnd(length, '0'));
}

/**
 * Prevent insertion if any time segment will become invalid
 * (and even zero padding won't help with it).
 * @example 2|0:00 => Type 9 => 2|0:00
 */
function createInvalidTimeSegmentInsertionPreprocessor({ timeMode, timeSegmentMinValues = DEFAULT_TIME_SEGMENT_MIN_VALUES, timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES, parseValue = (x) => ({ timeString: x }), }) {
    const invalidCharsRegExp = new RegExp(`[^\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]+`);
    return ({ elementState, data }, actionType) => {
        if (actionType !== 'insert') {
            return { elementState, data };
        }
        const { value, selection } = elementState;
        const [from, rawTo] = selection;
        const newCharacters = data.replace(invalidCharsRegExp, '');
        const to = rawTo + newCharacters.length; // to be conformed with `overwriteMode: replace`
        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);
        const { timeString, restValue = '' } = parseValue(newPossibleValue);
        const timeSegments = Object.entries(parseTimeString(timeString, timeMode));
        let offset = restValue.length;
        for (const [segmentName, stringifiedSegmentValue] of timeSegments) {
            const minSegmentValue = timeSegmentMinValues[segmentName];
            const maxSegmentValue = timeSegmentMaxValues[segmentName];
            const segmentValue = Number(stringifiedSegmentValue);
            const lastSegmentDigitIndex = offset + TIME_SEGMENT_VALUE_LENGTHS[segmentName];
            if (lastSegmentDigitIndex >= from &&
                lastSegmentDigitIndex <= to &&
                segmentValue !== clamp(segmentValue, minSegmentValue, maxSegmentValue)) {
                return { elementState, data: '' }; // prevent insertion
            }
            offset +=
                stringifiedSegmentValue.length +
                    // any time segment separator
                    1;
        }
        return { elementState, data };
    };
}

function createMeridiemPreprocessor(timeMode) {
    if (!timeMode.includes('AA')) {
        return identity;
    }
    const mainMeridiemCharRE = /^[AP]$/gi;
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        const newValue = value.toUpperCase();
        const newData = data.toUpperCase();
        if (newValue.match(ALL_MERIDIEM_CHARACTERS_RE) &&
            newData.match(mainMeridiemCharRE)) {
            return {
                elementState: {
                    value: newValue.replaceAll(ALL_MERIDIEM_CHARACTERS_RE, ''),
                    selection,
                },
                data: `${newData}M`,
            };
        }
        return { elementState: { selection, value: newValue }, data: newData };
    };
}
function createMeridiemPostprocessor(timeMode) {
    if (!timeMode.includes('AA')) {
        return identity;
    }
    return ({ value, selection }, initialElementState) => {
        if (!value.match(ANY_MERIDIEM_CHARACTER_RE) ||
            value.match(ALL_MERIDIEM_CHARACTERS_RE)) {
            return { value, selection };
        }
        const [from, to] = selection;
        // any meridiem character was deleted
        if (initialElementState.value.match(ALL_MERIDIEM_CHARACTERS_RE)) {
            const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, '');
            return {
                value: newValue,
                selection: [
                    Math.min(from, newValue.length),
                    Math.min(to, newValue.length),
                ],
            };
        }
        const fullMeridiem = `${CHAR_NO_BREAK_SPACE}${value.includes('P') ? 'P' : 'A'}M`;
        const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, (x) => x !== CHAR_NO_BREAK_SPACE ? fullMeridiem : x);
        return {
            value: newValue,
            selection: to >= newValue.indexOf(fullMeridiem)
                ? [newValue.length, newValue.length]
                : selection,
        };
    };
}

function raiseSegmentValueToMin(segments, fullMode) {
    const segmentsLength = getDateSegmentValueLength(fullMode);
    return Object.fromEntries(Object.entries(segments).map(([key, value]) => {
        const segmentLength = segmentsLength[key];
        return [
            key,
            value.length === segmentLength && /^0+$/.exec(value)
                ? '1'.padStart(segmentLength, '0')
                : value,
        ];
    }));
}

const LEAP_YEAR = '1972';
function createMinMaxDatePostprocessor({ dateModeTemplate, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, rangeSeparator = '', dateSegmentSeparator = '.', }) {
    return ({ value, selection }) => {
        const endsWithRangeSeparator = rangeSeparator && value.endsWith(rangeSeparator);
        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);
        let validatedValue = '';
        for (const dateString of dateStrings) {
            validatedValue += validatedValue ? rangeSeparator : '';
            const parsedDate = parseDateString(dateString, dateModeTemplate);
            if (!isDateStringComplete(dateString, dateModeTemplate)) {
                const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);
                const fixedValue = toDateString(fixedDate, { dateMode: dateModeTemplate });
                const tail = dateString.endsWith(dateSegmentSeparator)
                    ? dateSegmentSeparator
                    : '';
                validatedValue += fixedValue + tail;
                continue;
            }
            const date = segmentsToDate(Object.assign({ year: LEAP_YEAR }, parsedDate));
            const clampedDate = clamp(date, min, max);
            validatedValue += toDateString(dateToSegments(clampedDate), {
                dateMode: dateModeTemplate,
            });
        }
        return {
            selection,
            value: validatedValue + (endsWithRangeSeparator ? rangeSeparator : ''),
        };
    };
}

function normalizeDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', dateTimeSeparator = DATE_TIME_SEPARATOR, }) {
    return ({ elementState, data }) => {
        const templateSegments = dateModeTemplate.split(dateSegmentsSeparator);
        const includesTime = data.includes(dateTimeSeparator);
        const dateSegments = data
            .slice(0, includesTime ? data.indexOf(dateTimeSeparator) : Infinity)
            .split(/\D/)
            .filter(Boolean);
        if (!dateSegments.length || dateSegments.length % templateSegments.length !== 0) {
            return { elementState, data };
        }
        const dates = dateSegments.reduce((dates, segment, index) => {
            var _a;
            const template = (_a = templateSegments[index % templateSegments.length]) !== null && _a !== void 0 ? _a : '';
            const dateIndex = Math.trunc(index / templateSegments.length);
            const isLastDateSegment = index % templateSegments.length === templateSegments.length - 1;
            if (!dates[dateIndex]) {
                dates[dateIndex] = '';
            }
            dates[dateIndex] += isLastDateSegment
                ? segment
                : `${segment.padStart(template.length, '0')}${dateSegmentsSeparator}`;
            return dates;
        }, []);
        return {
            elementState,
            data: includesTime
                ? `${dates[0]}${data.slice(data.indexOf(dateTimeSeparator))}`
                : dates.join(rangeSeparator),
        };
    };
}

function maskitoPostfixPostprocessorGenerator(postfix) {
    const completedPostfixRE = new RegExp(`${escapeRegExp(postfix)}$`);
    const incompletePostfixRE = new RegExp(postfix &&
        `(${postfix
            .split('')
            .map(escapeRegExp)
            // eslint-disable-next-line
            .reduce((acc, _, i, arr) => `${acc}|${arr.slice(0, i + 1).join('')}`)})$`);
    return postfix
        ? ({ value, selection }, initialElementState) => {
            if (!value && !initialElementState.value.endsWith(postfix)) {
                // cases when developer wants input to be empty (programmatically)
                return { value, selection };
            }
            if (!value.match(incompletePostfixRE) &&
                !initialElementState.value.endsWith(postfix)) {
                return { selection, value: value + postfix };
            }
            const initialValueBeforePostfix = initialElementState.value.replace(completedPostfixRE, '');
            const postfixWasModified = initialElementState.selection[1] > initialValueBeforePostfix.length;
            const alreadyExistedValueBeforePostfix = findCommonBeginningSubstr(initialValueBeforePostfix, value);
            return {
                selection,
                value: Array.from(postfix)
                    .reverse()
                    .reduce((newValue, char, index) => {
                    const i = newValue.length - 1 - index;
                    const isInitiallyMirroredChar = alreadyExistedValueBeforePostfix[i] === char &&
                        postfixWasModified;
                    return newValue[i] !== char || isInitiallyMirroredChar
                        ? newValue.slice(0, i + 1) + char + newValue.slice(i + 1)
                        : newValue;
                }, value),
            };
        }
        : identity;
}

function maskitoPrefixPostprocessorGenerator(prefix) {
    return prefix
        ? ({ value, selection }, initialElementState) => {
            if (value.startsWith(prefix) || // already valid
                (!value && !initialElementState.value.startsWith(prefix)) // cases when developer wants input to be empty
            ) {
                return { value, selection };
            }
            const [from, to] = selection;
            const prefixedValue = Array.from(prefix).reduce((modifiedValue, char, i) => modifiedValue[i] === char
                ? modifiedValue
                : modifiedValue.slice(0, i) + char + modifiedValue.slice(i), value);
            const addedCharsCount = prefixedValue.length - value.length;
            return {
                selection: [from + addedCharsCount, to + addedCharsCount],
                value: prefixedValue,
            };
        }
        : identity;
}

function createValidDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', }) {
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        if (data === dateSegmentsSeparator) {
            return {
                elementState,
                data: selection[0] === value.length ? data : '',
            };
        }
        if (!data.replaceAll(/\D/g, '')) {
            return { elementState, data };
        }
        const newCharacters = data.replaceAll(new RegExp(`[^\\d${escapeRegExp(dateSegmentsSeparator)}${rangeSeparator}]`, 'g'), '');
        const [from, rawTo] = selection;
        let to = rawTo + data.length;
        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);
        const dateStrings = parseDateRangeString(newPossibleValue, dateModeTemplate, rangeSeparator);
        let validatedValue = '';
        const hasRangeSeparator = Boolean(rangeSeparator) && newPossibleValue.includes(rangeSeparator);
        for (const dateString of dateStrings) {
            const { validatedDateString, updatedSelection } = validateDateString({
                dateString,
                dateModeTemplate,
                dateSegmentsSeparator,
                offset: validatedValue.length,
                selection: [from, to],
            });
            if (dateString && !validatedDateString) {
                return { elementState, data: '' }; // prevent changes
            }
            to = updatedSelection[1];
            validatedValue +=
                hasRangeSeparator && !validatedValue
                    ? validatedDateString + rangeSeparator
                    : validatedDateString;
        }
        const newData = validatedValue.slice(from, to);
        return {
            elementState: {
                selection,
                value: validatedValue.slice(0, from) +
                    newData
                        .split(dateSegmentsSeparator)
                        .map((segment) => '0'.repeat(segment.length))
                        .join(dateSegmentsSeparator) +
                    validatedValue.slice(to),
            },
            data: newData,
        };
    };
}

function maskitoEventHandler(name, handler, eventListenerOptions) {
    return (element, maskitoOptions) => {
        const listener = () => handler(element, maskitoOptions);
        element.addEventListener(name, listener, eventListenerOptions);
        return () => element.removeEventListener(name, listener, eventListenerOptions);
    };
}

function maskitoAddOnFocusPlugin(value) {
    return maskitoEventHandler('focus', (element) => {
        if (!element.value) {
            maskitoUpdateElement(element, value);
        }
    });
}

function maskitoSelectionChangeHandler(handler) {
    return (element, options) => {
        const document = element.ownerDocument;
        let isPointerDown = 0;
        const onPointerDown = () => isPointerDown++;
        const onPointerUp = () => {
            isPointerDown = Math.max(--isPointerDown, 0);
        };
        const listener = () => {
            if (!element.matches(':focus')) {
                return;
            }
            if (isPointerDown) {
                return document.addEventListener('mouseup', listener, {
                    once: true,
                    passive: true,
                });
            }
            handler(element, options);
        };
        document.addEventListener('selectionchange', listener, { passive: true });
        // Safari does not fire `selectionchange` on focus after programmatic update of textfield value
        element.addEventListener('focus', listener, { passive: true });
        element.addEventListener('mousedown', onPointerDown, { passive: true });
        document.addEventListener('mouseup', onPointerUp, { passive: true });
        return () => {
            document.removeEventListener('selectionchange', listener);
            element.removeEventListener('focus', listener);
            element.removeEventListener('mousedown', onPointerDown);
            document.removeEventListener('mouseup', onPointerUp);
        };
    };
}

function maskitoCaretGuard(guard) {
    return maskitoSelectionChangeHandler((element) => {
        var _a, _b;
        const start = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;
        const end = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;
        const [fromLimit, toLimit] = guard(element.value, [start, end]);
        if (fromLimit > start || toLimit < end) {
            element.setSelectionRange(clamp(start, fromLimit, toLimit), clamp(end, fromLimit, toLimit));
        }
    });
}

const maskitoRejectEvent = (element) => {
    const listener = () => {
        const value = element.value;
        element.addEventListener('beforeinput', (event) => {
            if (event.defaultPrevented && value === element.value) {
                element.dispatchEvent(new CustomEvent('maskitoReject', { bubbles: true }));
            }
        }, { once: true });
    };
    element.addEventListener('beforeinput', listener, true);
    return () => element.removeEventListener('beforeinput', listener, true);
};

function maskitoRemoveOnBlurPlugin(value) {
    return maskitoEventHandler('blur', (element) => {
        if (element.value === value) {
            maskitoUpdateElement(element, '');
        }
    });
}

function createMeridiemSteppingPlugin(meridiemStartIndex) {
    if (meridiemStartIndex < 0) {
        return noop;
    }
    return (element) => {
        const listener = (event) => {
            const caretIndex = Number(element.selectionStart);
            const value = element.value.toUpperCase();
            if ((event.key !== 'ArrowUp' && event.key !== 'ArrowDown') ||
                caretIndex < meridiemStartIndex) {
                return;
            }
            event.preventDefault();
            // eslint-disable-next-line no-nested-ternary
            const meridiemMainCharacter = value.includes('A')
                ? 'P'
                : value.includes('P') || event.key === 'ArrowUp'
                    ? 'A'
                    : 'P';
            const newMeridiem = `${CHAR_NO_BREAK_SPACE}${meridiemMainCharacter}M`;
            maskitoUpdateElement(element, {
                value: value.length === meridiemStartIndex
                    ? value + newMeridiem
                    : value.replace(ANY_MERIDIEM_CHARACTER_RE, newMeridiem),
                selection: [caretIndex, caretIndex],
            });
        };
        element.addEventListener('keydown', listener);
        return () => element.removeEventListener('keydown', listener);
    };
}

function createTimeSegmentsSteppingPlugin({ step, fullMode, timeSegmentMaxValues, }) {
    const segmentsIndexes = createTimeSegmentsIndexes(fullMode);
    return step <= 0
        ? noop
        : (element) => {
            const listener = (event) => {
                var _a;
                if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {
                    return;
                }
                event.preventDefault();
                const selectionStart = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;
                const activeSegment = getActiveSegment({
                    segmentsIndexes,
                    selectionStart,
                });
                if (!activeSegment) {
                    return;
                }
                const updatedValue = updateSegmentValue({
                    selection: segmentsIndexes.get(activeSegment),
                    value: element.value,
                    toAdd: event.key === 'ArrowUp' ? step : -step,
                    max: timeSegmentMaxValues[activeSegment],
                });
                maskitoUpdateElement(element, {
                    value: updatedValue,
                    selection: [selectionStart, selectionStart],
                });
            };
            element.addEventListener('keydown', listener);
            return () => element.removeEventListener('keydown', listener);
        };
}
function createTimeSegmentsIndexes(fullMode) {
    return new Map([
        ['hours', getSegmentRange(fullMode, 'HH')],
        ['milliseconds', getSegmentRange(fullMode, 'MSS')],
        ['minutes', getSegmentRange(fullMode, 'MM')],
        ['seconds', getSegmentRange(fullMode, 'SS')],
    ]);
}
function getSegmentRange(mode, segment) {
    const index = mode.indexOf(segment);
    return index === -1 ? [-1, -1] : [index, index + segment.length];
}
function getActiveSegment({ segmentsIndexes, selectionStart, }) {
    for (const [segmentName, segmentRange] of segmentsIndexes.entries()) {
        const [from, to] = segmentRange;
        if (from <= selectionStart && selectionStart <= to) {
            return segmentName;
        }
    }
    return null;
}
function updateSegmentValue({ selection, value, toAdd, max, }) {
    const [from, to] = selection;
    const segmentValue = Number(value.slice(from, to).padEnd(to - from, '0'));
    const newSegmentValue = mod(segmentValue + toAdd, max + 1);
    return (value.slice(0, from) +
        String(newSegmentValue).padStart(to - from, '0') +
        value.slice(to, value.length));
}
function mod(value, max) {
    if (value < 0) {
        value += Math.floor(Math.abs(value) / max + 1) * max;
    }
    return value % max;
}

function maskitoWithPlaceholder(placeholder, focusedOnly = false) {
    let lastClearValue = '';
    let action = 'validation';
    const removePlaceholder = (value) => {
        for (let i = value.length - 1; i >= lastClearValue.length; i--) {
            if (value[i] !== placeholder[i]) {
                return value.slice(0, i + 1);
            }
        }
        return value.slice(0, lastClearValue.length);
    };
    const plugins = [maskitoCaretGuard((value) => [0, removePlaceholder(value).length])];
    let focused = false;
    if (focusedOnly) {
        const focus = maskitoEventHandler('focus', (element) => {
            focused = true;
            maskitoUpdateElement(element, element.value + placeholder.slice(element.value.length));
        }, { capture: true });
        const blur = maskitoEventHandler('blur', (element) => {
            focused = false;
            maskitoUpdateElement(element, removePlaceholder(element.value));
        }, { capture: true });
        plugins.push(focus, blur);
    }
    return {
        plugins,
        removePlaceholder,
        preprocessors: [
            ({ elementState, data }, actionType) => {
                action = actionType;
                const { value, selection } = elementState;
                return {
                    elementState: {
                        selection,
                        value: removePlaceholder(value),
                    },
                    data,
                };
            },
        ],
        postprocessors: [
            ({ value, selection }, initialElementState) => {
                lastClearValue = value;
                const justPlaceholderRemoval = value +
                    placeholder.slice(value.length, initialElementState.value.length) ===
                    initialElementState.value;
                if (action === 'validation' && justPlaceholderRemoval) {
                    /**
                     * If `value` still equals to `initialElementState.value`,
                     * then it means that value is patched programmatically (from Maskito's plugin or externally).
                     * In this case, we don't want to mutate value and automatically add/remove placeholder.
                     * ___
                     * For example, developer wants to remove manually placeholder (+ do something else with value) on blur.
                     * Without this condition, placeholder will be unexpectedly added again.
                     */
                    return { selection, value: initialElementState.value };
                }
                const newValue = focused || !focusedOnly
                    ? value + placeholder.slice(value.length)
                    : value;
                if (newValue === initialElementState.value &&
                    action === 'deleteBackward') {
                    const [caretIndex] = initialElementState.selection;
                    return {
                        value: newValue,
                        selection: [caretIndex, caretIndex],
                    };
                }
                return { value: newValue, selection };
            },
        ],
    };
}

function createZeroPlaceholdersPreprocessor(postfix = '') {
    const isLastChar = (value, [_, to]) => to >= value.length - postfix.length;
    return ({ elementState }, actionType) => {
        const { value, selection } = elementState;
        if (!value || isLastChar(value, selection)) {
            return { elementState };
        }
        const [from, to] = selection;
        const zeroes = value.slice(from, to).replaceAll(/\d/g, '0');
        const newValue = value.slice(0, from) + zeroes + value.slice(to);
        if (!zeroes.replaceAll(/\D/g, '')) {
            return { elementState };
        }
        if (actionType === 'validation' || (actionType === 'insert' && from === to)) {
            return {
                elementState: { selection, value: newValue },
            };
        }
        return {
            elementState: {
                selection: actionType === 'deleteBackward' || actionType === 'insert'
                    ? [from, from]
                    : [to, to],
                value: newValue,
            },
        };
    };
}

function maskitoDateOptionsGenerator({ mode, separator = '.', max, min, }) {
    const dateModeTemplate = mode.split('/').join(separator);
    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: Array.from(dateModeTemplate).map((char) => separator.includes(char) ? char : /\d/), overwriteMode: 'replace', preprocessors: [
            createFullWidthToHalfWidthPreprocessor(),
            createZeroPlaceholdersPreprocessor(),
            normalizeDatePreprocessor({
                dateModeTemplate,
                dateSegmentsSeparator: separator,
            }),
            createValidDatePreprocessor({
                dateModeTemplate,
                dateSegmentsSeparator: separator,
            }),
        ], postprocessors: [
            createDateSegmentsZeroPaddingPostprocessor({
                dateModeTemplate,
                dateSegmentSeparator: separator,
                splitFn: (value) => ({ dateStrings: [value] }),
                uniteFn: ([dateString = '']) => dateString,
            }),
            createMinMaxDatePostprocessor({
                min,
                max,
                dateModeTemplate,
                dateSegmentSeparator: separator,
            }),
        ] });
}

function maskitoParseDate(value, { mode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE }) {
    if (value.length < mode.length) {
        return null;
    }
    const dateSegments = parseDateString(value, mode);
    const parsedDate = segmentsToDate(dateSegments);
    return clamp(parsedDate, min, max);
}

const formatter = Intl.DateTimeFormat('en-US', {
    month: '2-digit',
    day: '2-digit',
    year: 'numeric',
});
function toDateSegments(date) {
    return formatter
        .formatToParts(date)
        .reduce((acc, part) => (Object.assign(Object.assign({}, acc), { [part.type]: part.value })), {});
}

function maskitoStringifyDate(date, { mode, separator = '.', min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, }) {
    const validatedDate = clamp(date, min, max);
    const segments = toDateSegments(validatedDate);
    return toDateString(segments, {
        dateMode: mode.replaceAll('/', separator),
    });
}

function createMinMaxRangeLengthPostprocessor({ dateModeTemplate, rangeSeparator, minLength, maxLength, max = DEFAULT_MAX_DATE, }) {
    if (isEmpty(minLength) && isEmpty(maxLength)) {
        return identity;
    }
    return ({ value, selection }) => {
        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);
        if (dateStrings.length !== 2 ||
            dateStrings.some((date) => !isDateStringComplete(date, dateModeTemplate))) {
            return { value, selection };
        }
        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));
        if (!fromDate || !toDate) {
            return { value, selection };
        }
        const minDistantToDate = appendDate(fromDate, minLength);
        const maxDistantToDate = !isEmpty(maxLength)
            ? appendDate(fromDate, maxLength)
            : max;
        const minLengthClampedToDate = clamp(toDate, minDistantToDate, max);
        const minMaxLengthClampedToDate = minLengthClampedToDate > maxDistantToDate
            ? maxDistantToDate
            : minLengthClampedToDate;
        return {
            selection,
            value: dateStrings[0] +
                rangeSeparator +
                toDateString(dateToSegments(minMaxLengthClampedToDate), {
                    dateMode: dateModeTemplate,
                }),
        };
    };
}

function createSwapDatesPostprocessor({ dateModeTemplate, rangeSeparator, }) {
    return ({ value, selection }) => {
        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);
        const isDateRangeComplete = dateStrings.length === 2 &&
            dateStrings.every((date) => isDateStringComplete(date, dateModeTemplate));
        const [from, to] = selection;
        const caretAtTheEnd = from >= value.length;
        const allValueSelected = from === 0 && to >= value.length; // dropping text inside with a pointer
        if (!(caretAtTheEnd || allValueSelected) || !isDateRangeComplete) {
            return { value, selection };
        }
        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));
        return {
            selection,
            value: fromDate && toDate && fromDate > toDate
                ? dateStrings.reverse().join(rangeSeparator)
                : value,
        };
    };
}

function maskitoDateRangeOptionsGenerator({ mode, min, max, minLength, maxLength, dateSeparator = '.', rangeSeparator = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`, }) {
    const dateModeTemplate = mode.split('/').join(dateSeparator);
    const dateMask = Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\d/);
    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [...dateMask, ...Array.from(rangeSeparator), ...dateMask], overwriteMode: 'replace', preprocessors: [
            createFullWidthToHalfWidthPreprocessor(),
            createFirstDateEndSeparatorPreprocessor({
                dateModeTemplate,
                dateSegmentSeparator: dateSeparator,
                firstDateEndSeparator: rangeSeparator,
                pseudoFirstDateEndSeparators: POSSIBLE_DATE_RANGE_SEPARATOR,
            }),
            createZeroPlaceholdersPreprocessor(),
            normalizeDatePreprocessor({
                dateModeTemplate,
                rangeSeparator,
                dateSegmentsSeparator: dateSeparator,
            }),
            createValidDatePreprocessor({
                dateModeTemplate,
                rangeSeparator,
                dateSegmentsSeparator: dateSeparator,
            }),
        ], postprocessors: [
            createDateSegmentsZeroPaddingPostprocessor({
                dateModeTemplate,
                dateSegmentSeparator: dateSeparator,
                splitFn: (value) => ({
                    dateStrings: parseDateRangeString(value, dateModeTemplate, rangeSeparator),
                }),
                uniteFn: (validatedDateStrings, initialValue) => validatedDateStrings.reduce((acc, dateString, dateIndex) => acc +
                    dateString +
                    (!dateIndex && initialValue.includes(rangeSeparator)
                        ? rangeSeparator
                        : ''), ''),
            }),
            createMinMaxDatePostprocessor({
                min,
                max,
                dateModeTemplate,
                rangeSeparator,
                dateSegmentSeparator: dateSeparator,
            }),
            createMinMaxRangeLengthPostprocessor({
                dateModeTemplate,
                minLength,
                maxLength,
                max,
                rangeSeparator,
            }),
            createSwapDatesPostprocessor({
                dateModeTemplate,
                rangeSeparator,
            }),
        ] });
}

function isDateTimeStringComplete(dateTimeString, { dateMode, timeMode, dateTimeSeparator = DATE_TIME_SEPARATOR, }) {
    var _a;
    return (dateTimeString.length >=
        dateMode.length + timeMode.length + dateTimeSeparator.length &&
        ((_a = dateTimeString.split(dateTimeSeparator)[0]) !== null && _a !== void 0 ? _a : '')
            .split(/\D/)
            .every((segment) => !/^0+$/.exec(segment)));
}

function maskitoTimeOptionsGenerator({ mode, timeSegmentMaxValues = {}, timeSegmentMinValues = {}, step = 0, prefix = '', postfix = '', }) {
    const hasMeridiem = mode.includes('AA');
    const enrichedTimeSegmentMaxValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), (hasMeridiem ? { hours: 12 } : {})), timeSegmentMaxValues);
    const enrichedTimeSegmentMinValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), (hasMeridiem ? { hours: 1 } : {})), timeSegmentMinValues);
    const maskExpression = [...prefix, ...createTimeMaskExpression(mode)];
    return {
        mask: postfix
            ? ({ value }) => cutExpression(maskExpression, value).concat(...postfix)
            : maskExpression,
        preprocessors: [
            createFullWidthToHalfWidthPreprocessor(),
            createColonConvertPreprocessor(),
            createZeroPlaceholdersPreprocessor(postfix),
            createMeridiemPreprocessor(mode),
            createInvalidTimeSegmentInsertionPreprocessor({
                timeMode: mode,
                timeSegmentMinValues: enrichedTimeSegmentMinValues,
                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,
            }),
        ],
        postprocessors: [
            createMeridiemPostprocessor(mode),
            (elementState) => enrichTimeSegmentsWithZeroes(elementState, {
                mode,
                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,
            }),
            maskitoPrefixPostprocessorGenerator(prefix),
            maskitoPostfixPostprocessorGenerator(postfix),
        ],
        plugins: [
            createTimeSegmentsSteppingPlugin({
                fullMode: mode,
                step,
                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,
            }),
            createMeridiemSteppingPlugin(mode.indexOf('AA')),
        ],
        overwriteMode: 'replace',
    };
}
/**
 * Without cutting, the mask expression removes postfix on the last digit deletion
 * ___
 * Case 1 (static pattern mask expression)
 * Mask expression is [/\d/, /\d/, ':', /\d/, /\d/, ' left']
 * 12:34| left => Press Backspace => 12:3|
 * Mask correctly removes postfix because it's fixed characters after not yet inserted 4th digit.
 * ___
 * Case 2 (dynamic pattern mask expression)
 * Mask expression is [/\d/, /\d/, ':', /\d/, /\d/, ' left'] & textfield contains `12:34 left`
 * 12:34| left => Press Backspace => Mask expression becomes [/\d/, /\d/, ':', /\d/, ' left']  => 12:3| left
 * Mask correctly does not remove postfix because it's trailing fixed characters
 * and all non-fixed characters were already inserted.
 */
function cutExpression(expression, value) {
    let digitsCount = Math.min(value.replaceAll(/\D/g, '').length, expression.filter((x) => typeof x !== 'string').length) || 1;
    const afterLastDigit = expression.findIndex((x) => typeof x !== 'string' && !--digitsCount) + 1;
    return expression.slice(0, afterLastDigit);
}

/**
 * Converts a formatted time string to milliseconds based on the given `options.mode`.
 *
 * @param maskedTime a formatted time string by {@link maskitoTimeOptionsGenerator} or {@link maskitoStringifyTime}
 * @param params
 */
function maskitoParseTime(maskedTime, { mode, timeSegmentMaxValues = {} }) {
    var _a, _b, _c, _d;
    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);
    const msInSecond = maxValues.milliseconds + 1;
    const msInMinute = (maxValues.seconds + 1) * msInSecond;
    const msInHour = (maxValues.minutes + 1) * msInMinute;
    const parsedTime = padEndTimeSegments(parseTimeString(maskedTime, mode));
    let hours = Number((_a = parsedTime.hours) !== null && _a !== void 0 ? _a : '');
    if (mode.includes('AA') && Number.isFinite(hours)) {
        if (maskedTime.includes('PM')) {
            hours = hours < 12 ? hours + 12 : hours;
        }
        else {
            hours = hours === 12 ? 0 : hours;
        }
    }
    return (hours * msInHour +
        Number((_b = parsedTime.minutes) !== null && _b !== void 0 ? _b : '') * msInMinute +
        Number((_c = parsedTime.seconds) !== null && _c !== void 0 ? _c : '') * msInSecond +
        Number((_d = parsedTime.milliseconds) !== null && _d !== void 0 ? _d : ''));
}

/**
 * Converts milliseconds to a formatted time string based on the given `options.mode`.
 *
 * @param milliseconds unsigned integer milliseconds
 * @param params
 */
function maskitoStringifyTime(milliseconds, { mode, timeSegmentMaxValues = {} }) {
    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);
    const hasMeridiem = mode.includes('AA');
    const msInSecond = maxValues.milliseconds + 1;
    const msInMinute = (maxValues.seconds + 1) * msInSecond;
    const msInHour = (maxValues.minutes + 1) * msInMinute;
    const hours = Math.trunc(milliseconds / msInHour);
    milliseconds -= hours * msInHour;
    const minutes = Math.trunc(milliseconds / msInMinute);
    milliseconds -= minutes * msInMinute;
    const seconds = Math.trunc(milliseconds / msInSecond);
    milliseconds -= seconds * msInSecond;
    const result = padStartTimeSegments({
        hours: hasMeridiem ? hours % 12 || 12 : hours,
        minutes,
        seconds,
        milliseconds,
    });
    return mode
        .replaceAll(/H+/g, result.hours)
        .replaceAll('MSS', result.milliseconds)
        .replaceAll(/M+/g, result.minutes)
        .replaceAll(/S+/g, result.seconds)
        .replace('AA', hours >= 12 ? 'PM' : 'AM');
}

function maskitoParseDateTime(value, { dateMode, timeMode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, dateTimeSeparator = DATE_TIME_SEPARATOR, }) {
    const [dateSegment = '', timeSegment = ''] = value.split(dateTimeSeparator);
    if (timeSegment.length !== timeMode.length) {
        return null;
    }
    const date = maskitoParseDate(dateSegment, { mode: dateMode });
    const time = maskitoParseTime(timeSegment, { mode: timeMode });
    if (!date) {
        return null;
    }
    const dateTime = new Date(Number(date) + time);
    return clamp(dateTime, min, max);
}

const NON_DIGIT_PLACEHOLDER_RE = /[^dmy]/g;
const LEADING_NON_DIGIT_RE = /^\D*/;
function splitDateTimeString(dateTime, dateModeTemplate) {
    const dateDigitsCount = dateModeTemplate.replaceAll(NON_DIGIT_PLACEHOLDER_RE, '').length;
    const [date = ''] = new RegExp(`(\\d[^\\d]*){0,${dateDigitsCount - 1}}\\d?`).exec(dateTime) || [];
    const [dateTimeSeparator = ''] = LEADING_NON_DIGIT_RE.exec(dateTime.slice(date.length)) || [];
    return [date, dateTime.slice(date.length + dateTimeSeparator.length)];
}

function maskitoStringifyDateTime(date, { dateMode, timeMode, dateTimeSeparator = DATE_TIME_SEPARATOR, dateSeparator = '.', min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, }) {
    const validatedDate = clamp(date, min, max);
    const dateString = maskitoStringifyDate(validatedDate, {
        mode: dateMode,
        separator: dateSeparator,
        min,
        max,
    });
    const extractedTime = Number(validatedDate) -
        Number(new Date(validatedDate.getFullYear(), validatedDate.getMonth(), validatedDate.getDate()));
    const timeString = maskitoStringifyTime(extractedTime, { mode: timeMode });
    return dateString + dateTimeSeparator + timeString;
}

function createMinMaxDateTimePostprocessor({ dateModeTemplate, timeMode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, dateTimeSeparator, }) {
    return ({ value, selection }) => {
        const [dateString, timeString] = splitDateTimeString(value, dateModeTemplate);
        const parsedDate = parseDateString(dateString, dateModeTemplate);
        const parsedTime = parseTimeString(timeString, timeMode);
        if (!isDateTimeStringComplete(value, {
            dateMode: dateModeTemplate,
            timeMode,
            dateTimeSeparator,
        })) {
            const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);
            const { year, month, day } = isDateStringComplete(dateString, dateModeTemplate)
                ? dateToSegments(clamp(segmentsToDate(fixedDate), min, max))
                : fixedDate;
            const fixedValue = toDateString(Object.assign({ year,
                month,
                day }, parsedTime), { dateMode: dateModeTemplate, dateTimeSeparator, timeMode });
            const tail = value.slice(fixedValue.length);
            return {
                selection,
                value: fixedValue + tail,
            };
        }
        const date = segmentsToDate(parsedDate, parsedTime);
        const clampedDate = clamp(date, min, max);
        // trailing segment separators or meridiem characters
        const [trailingNonDigitCharacters = ''] = value.match(/\D+$/g) || [];
        const validatedValue = toDateString(dateToSegments(clampedDate), {
            dateMode: dateModeTemplate,
            dateTimeSeparator,
            timeMode,
        }) + trailingNonDigitCharacters;
        return {
            selection,
            value: validatedValue,
        };
    };
}

function createValidDateTimePreprocessor({ dateModeTemplate, dateSegmentsSeparator, dateTimeSeparator, timeMode, timeSegmentMaxValues, }) {
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        if (data === dateSegmentsSeparator) {
            return {
                elementState,
                data: selection[0] === value.length ? data : '',
            };
        }
        const newCharacters = data.replaceAll(/\D/g, '');
        if (!newCharacters) {
            return { elementState, data };
        }
        const [from, rawTo] = selection;
        let to = rawTo + data.length;
        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);
        const [dateString, timeString] = splitDateTimeString(newPossibleValue, dateModeTemplate);
        let validatedValue = '';
        const hasDateTimeSeparator = newPossibleValue.includes(dateTimeSeparator);
        const { validatedDateString, updatedSelection } = validateDateString({
            dateString,
            dateSegmentsSeparator,
            dateModeTemplate,
            offset: 0,
            selection: [from, to],
        });
        if (dateString && !validatedDateString) {
            return { elementState, data: '' }; // prevent changes
        }
        to = updatedSelection[1];
        validatedValue += validatedDateString;
        const updatedTimeState = enrichTimeSegmentsWithZeroes({ value: timeString, selection: [from, to] }, { mode: timeMode, timeSegmentMaxValues });
        to = updatedTimeState.selection[1];
        validatedValue += hasDateTimeSeparator
            ? dateTimeSeparator + updatedTimeState.value
            : updatedTimeState.value;
        const newData = validatedValue.slice(from, to);
        return {
            elementState: {
                selection,
                value: validatedValue.slice(0, from) +
                    newData
                        .split(dateSegmentsSeparator)
                        .map((segment) => '0'.repeat(segment.length))
                        .join(dateSegmentsSeparator) +
                    validatedValue.slice(to),
            },
            data: newData,
        };
    };
}

function maskitoDateTimeOptionsGenerator({ dateMode, timeMode, dateSeparator = '.', min, max, dateTimeSeparator = DATE_TIME_SEPARATOR, timeStep = 0, }) {
    const hasMeridiem = timeMode.includes('AA');
    const dateModeTemplate = dateMode.split('/').join(dateSeparator);
    const timeSegmentMaxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), (hasMeridiem ? { hours: 12 } : {}));
    const timeSegmentMinValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), (hasMeridiem ? { hours: 1 } : {}));
    const fullMode = `${dateModeTemplate}${dateTimeSeparator}${timeMode}`;
    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [
            ...Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\d/),
            ...dateTimeSeparator.split(''),
            ...createTimeMaskExpression(timeMode),
        ], overwriteMode: 'replace', preprocessors: [
            createFullWidthToHalfWidthPreprocessor(),
            createColonConvertPreprocessor(),
            createFirstDateEndSeparatorPreprocessor({
                dateModeTemplate,
                dateSegmentSeparator: dateSeparator,
                firstDateEndSeparator: dateTimeSeparator,
                pseudoFirstDateEndSeparators: dateTimeSeparator.split(''),
            }),
            createZeroPlaceholdersPreprocessor(),
            createMeridiemPreprocessor(timeMode),
            normalizeDatePreprocessor({
                dateModeTemplate,
                dateSegmentsSeparator: dateSeparator,
                dateTimeSeparator,
            }),
            createInvalidTimeSegmentInsertionPreprocessor({
                timeMode,
                timeSegmentMinValues,
                timeSegmentMaxValues,
                parseValue: (x) => {
                    const [dateString, timeString] = splitDateTimeString(x, dateModeTemplate);
                    return { timeString, restValue: dateString + dateTimeSeparator };
                },
            }),
            createValidDateTimePreprocessor({
                dateModeTemplate,
                dateSegmentsSeparator: dateSeparator,
                dateTimeSeparator,
                timeMode,
                timeSegmentMaxValues,
            }),
        ], postprocessors: [
            createMeridiemPostprocessor(timeMode),
            createDateSegmentsZeroPaddingPostprocessor({
                dateModeTemplate,
                dateSegmentSeparator: dateSeparator,
                splitFn: (value) => {
                    const [dateString, timeString] = splitDateTimeString(value, dateModeTemplate);
                    return { dateStrings: [dateString], restPart: timeString };
                },
                uniteFn: ([validatedDateString], initialValue) => validatedDateString +
                    (initialValue.includes(dateTimeSeparator) ? dateTimeSeparator : ''),
            }),
            createMinMaxDateTimePostprocessor({
                min,
                max,
                dateModeTemplate,
                timeMode,
                dateTimeSeparator,
            }),
        ], plugins: [
            createTimeSegmentsSteppingPlugin({
                step: timeStep,
                fullMode,
                timeSegmentMaxValues: DEFAULT_TIME_SEGMENT_MAX_VALUES,
            }),
            createMeridiemSteppingPlugin(fullMode.indexOf('AA')),
        ] });
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function extractAffixes(value, { prefix, postfix, decimalSeparator, decimalPseudoSeparators, minusSign, minusPseudoSigns, maximumFractionDigits, }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const decimalSeparators = [...decimalPseudoSeparators, decimalSeparator]
        .map((x) => `\\${x}`)
        .join('');
    const minuses = [...minusPseudoSigns, minusSign].map((x) => `\\${x}`).join('');
    const prefixRegExp = prefix &&
        new RegExp(`^([${minuses}])?(${prefix.split('').map(escapeRegExp).join('?')}?)`);
    const postfixRegExp = postfix && new RegExp(`${postfix.split('').map(escapeRegExp).join('?')}?$`);
    const [, , extractedPrefix = ''] = (_a = value.match(prefixRegExp)) !== null && _a !== void 0 ? _a : [];
    const [extractedPostfix = ''] = (_b = value.match(postfixRegExp)) !== null && _b !== void 0 ? _b : [];
    const cleanValue = value
        .replace(prefixRegExp, prefix && '$1')
        .replace(postfixRegExp, '');
    const leadingDecimalSeparatorRE = new RegExp(decimalSeparator && maximumFractionDigits > 0 ? `^[${decimalSeparators}]` : '');
    const leadingDigitsRE = new RegExp(value.endsWith(postfix) ? '' : String.raw `^\d+`);
    const trailingDecimalSeparatorRE = new RegExp(decimalSeparator && maximumFractionDigits > 0 ? `[${decimalSeparators}]$` : '');
    const trailingDigitsRE = new RegExp(value.startsWith(prefix) ? '' : String.raw `\d+$`);
    return {
        extractedPrefix: extractedPrefix
            .replace(trailingDecimalSeparatorRE, '')
            .replace(trailingDigitsRE, ''),
        extractedPostfix: extractedPostfix
            .replace(leadingDecimalSeparatorRE, '')
            .replace(leadingDigitsRE, ''),
        cleanValue: ((_d = (_c = trailingDigitsRE.exec(extractedPrefix)) === null || _c === void 0 ? void 0 : _c[0]) !== null && _d !== void 0 ? _d : '') +
            ((_f = (_e = trailingDecimalSeparatorRE.exec(extractedPrefix)) === null || _e === void 0 ? void 0 : _e[0]) !== null && _f !== void 0 ? _f : '') +
            cleanValue +
            ((_h = (_g = leadingDigitsRE.exec(extractedPostfix)) === null || _g === void 0 ? void 0 : _g[0]) !== null && _h !== void 0 ? _h : '') +
            ((_k = (_j = leadingDecimalSeparatorRE.exec(extractedPostfix)) === null || _j === void 0 ? void 0 : _j[0]) !== null && _k !== void 0 ? _k : ''),
    };
}

function generateMaskExpression({ decimalPseudoSeparators, decimalSeparator, maximumFractionDigits, min, minusSign, minusPseudoSigns, postfix, prefix, thousandSeparator, }) {
    const computedPrefix = min < 0 && [minusSign, ...minusPseudoSigns].includes(prefix)
        ? ''
        : computeAllOptionalCharsRegExp(prefix);
    const digit = String.raw `\d`;
    const optionalMinus = min < 0 ? `[${minusSign}${minusPseudoSigns.map((x) => `\\${x}`).join('')}]?` : '';
    const integerPart = thousandSeparator
        ? `[${digit}${escapeRegExp(thousandSeparator).replaceAll(/\s/g, String.raw `\s`)}]*`
        : `[${digit}]*`;
    const precisionPart = Number.isFinite(maximumFractionDigits)
        ? maximumFractionDigits
        : '';
    const decimalPart = maximumFractionDigits > 0
        ? `([${escapeRegExp(decimalSeparator)}${decimalPseudoSeparators
            .map(escapeRegExp)
            .join('')}]${digit}{0,${precisionPart}})?`
        : '';
    const computedPostfix = computeAllOptionalCharsRegExp(postfix);
    const beginning = `(${optionalMinus + computedPrefix}|${computedPrefix + optionalMinus})`;
    return new RegExp(`^${beginning}${integerPart}${decimalPart}${computedPostfix}$`);
}
function computeAllOptionalCharsRegExp(str) {
    return str
        ? `${str
            .split('')
            .map((char) => `${escapeRegExp(char)}?`)
            .join('')}`
        : '';
}

function toNumberParts(value, params) {
    var _a, _b;
    const { extractedPrefix, cleanValue, extractedPostfix } = extractAffixes(value, params);
    const { decimalSeparator, minusSign, minusPseudoSigns, decimalPseudoSeparators, maximumFractionDigits, } = params;
    const [integerWithMinus = '', decimalPart = ''] = decimalSeparator
        ? cleanValue.split(decimalSeparator)
        : [cleanValue];
    const minuses = [minusSign, ...minusPseudoSigns].map((x) => `\\${x}`).join('');
    const [, minus = '', integerPart = ''] = new RegExp(`^([${minuses}])?(.*)`).exec(integerWithMinus) || [];
    return {
        prefix: extractedPrefix,
        minus,
        integerPart,
        decimalPart,
        decimalSeparator: decimalSeparator && maximumFractionDigits > 0
            ? ((_b = (_a = new RegExp(`[${[decimalSeparator, ...decimalPseudoSeparators].map(escapeRegExp).join('')}]`, 'i').exec(cleanValue)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : '')
            : '',
        postfix: extractedPostfix,
    };
}
function fromNumberParts({ minus = '', integerPart = '', decimalPart = '', prefix = '', postfix = '', decimalSeparator = '', }, params) {
    const separator = decimalPart ? params.decimalSeparator : decimalSeparator;
    const beginning = params.negativePattern === 'minusFirst' ? minus + prefix : prefix + minus;
    return `${beginning}${integerPart}${separator}${decimalPart}${postfix}`;
}

function maskitoParseNumber(maskedNumber, 
// TODO(v4): decimalSeparatorOrParams: MaskitoNumberParams | string => params: MaskitoNumberParams = {}
decimalSeparatorOrParams = {}) {
    const { decimalSeparator = '.', minusSign = '', minusPseudoSigns = DEFAULT_PSEUDO_MINUSES, } = typeof decimalSeparatorOrParams === 'string'
        ? { decimalSeparator: decimalSeparatorOrParams }
        : decimalSeparatorOrParams;
    const hasNegativeSign = !!new RegExp(`^\\D*[${escapeRegExp(minusSign)}\\${minusPseudoSigns.join('\\')}]`).exec(maskedNumber);
    const escapedDecimalSeparator = escapeRegExp(decimalSeparator);
    const unmaskedNumber = maskedNumber
        // drop all decimal separators not followed by a digit
        .replaceAll(new RegExp(`${escapedDecimalSeparator}(?!\\d)`, 'g'), '')
        // drop all non-digit characters except decimal separator
        .replaceAll(new RegExp(`[^\\d${escapedDecimalSeparator}]`, 'g'), '')
        .replace(decimalSeparator, decimalSeparator && '.');
    if (unmaskedNumber) {
        const sign = hasNegativeSign ? CHAR_HYPHEN : '';
        return Number(`${sign}${unmaskedNumber}`);
    }
    return NaN;
}

/**
 * Convert number to string with replacing exponent part on decimals
 *
 * @param value the number
 * @return string representation of a number
 */
function stringifyNumberWithoutExp(value) {
    var _a;
    const valueAsString = String(value);
    const [numberPart = '', expPart] = valueAsString.split('e-');
    let valueWithoutExp = valueAsString;
    if (expPart) {
        const [, fractionalPart] = numberPart.split('.');
        const decimalDigits = Number(expPart) + ((_a = fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) !== null && _a !== void 0 ? _a : 0);
        valueWithoutExp = value.toFixed(decimalDigits);
    }
    return valueWithoutExp;
}

function validateDecimalPseudoSeparators({ decimalSeparator, thousandSeparator, decimalPseudoSeparators = DEFAULT_DECIMAL_PSEUDO_SEPARATORS, }) {
    return decimalPseudoSeparators.filter((char) => char !== thousandSeparator && char !== decimalSeparator);
}

/**
 * It drops prefix and postfix from data
 * Needed for case, when prefix or postfix contain decimalSeparator, to ignore it in resulting number
 * @example User pastes '{prefix}123.45{postfix}' => 123.45
 */
function createAffixesFilterPreprocessor(params) {
    return ({ elementState, data }) => {
        const { value } = elementState;
        const _a = toNumberParts(data, params), { prefix, postfix } = _a, numberParts = __rest(_a, ["prefix", "postfix"]);
        return {
            elementState,
            data: fromNumberParts(Object.assign(Object.assign({}, numberParts), { prefix: value.startsWith(prefix) ? '' : prefix, postfix: value.endsWith(postfix) ? '' : postfix }), params),
        };
    };
}

/**
 * If `minimumFractionDigits` is `>0`, it pads decimal part with zeroes
 * (until number of digits after decimalSeparator is equal to the `minimumFractionDigits`).
 * @example 1,42 => (`minimumFractionDigits` is equal to 4) => 1,4200.
 */
function createDecimalZeroPaddingPostprocessor(params) {
    const { minimumFractionDigits } = params;
    if (!minimumFractionDigits) {
        return identity;
    }
    return ({ value, selection }) => {
        if (Number.isNaN(maskitoParseNumber(value, params))) {
            return { value, selection };
        }
        const _a = toNumberParts(value, params), { decimalPart } = _a, numberParts = __rest(_a, ["decimalPart"]);
        return {
            value: fromNumberParts(Object.assign(Object.assign({}, numberParts), { decimalPart: decimalPart.padEnd(minimumFractionDigits, '0') }), params),
            selection,
        };
    };
}

/**
 * Make textfield empty if there is no integer part and all decimal digits are zeroes.
 * @example 0|,00 => Backspace => Empty.
 * @example -0|,00 => Backspace => -.
 * @example ,42| => Backspace x2 => ,|00 => Backspace => Empty
 */
function emptyPostprocessor(params) {
    return ({ value, selection }) => {
        const [caretIndex] = selection;
        const { prefix, minus, integerPart, decimalSeparator, decimalPart, postfix } = toNumberParts(value, params);
        const aloneDecimalSeparator = !integerPart && !decimalPart && decimalSeparator;
        if ((!integerPart &&
            !Number(decimalPart) &&
            caretIndex === (minus + prefix).length) ||
            aloneDecimalSeparator) {
            return {
                selection,
                value: fromNumberParts({ prefix, minus, postfix }, params),
            };
        }
        return { value, selection };
    };
}

/**
 * This preprocessor works only once at initialization phase (when `new Maskito(...)` is executed).
 * This preprocessor helps to avoid conflicts during transition from one mask to another (for the same input).
 * For example, the developer changes postfix (or other mask's props) during run-time.
 * ```
 * let maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' year'});
 * // [3 seconds later]
 * maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' years'});
 * ```
 */
function createInitializationOnlyPreprocessor(params) {
    let isInitializationPhase = true;
    const cleanNumberMask = generateMaskExpression(Object.assign(Object.assign({}, params), { prefix: '', postfix: '', thousandSeparator: '', maximumFractionDigits: Infinity, min: Number.MIN_SAFE_INTEGER }));
    return ({ elementState, data }) => {
        if (!isInitializationPhase) {
            return { elementState, data };
        }
        isInitializationPhase = false;
        const { value, selection } = elementState;
        const [from, to] = selection;
        const _a = toNumberParts(value, params), { prefix, postfix } = _a, numberParts = __rest(_a, ["prefix", "postfix"]);
        const onlyNumber = fromNumberParts(numberParts, params);
        const cleanState = maskitoTransform({
            selection: [
                Math.max(from - prefix.length, 0),
                Math.max(to - prefix.length, 0),
            ],
            value: onlyNumber,
        }, {
            mask: cleanNumberMask,
        });
        const deleted = onlyNumber.slice(0, Math.max(to - prefix.length, 0)).length -
            cleanState.value.slice(0, cleanState.selection[1]).length;
        return {
            elementState: {
                selection: [Math.max(from - deleted, 0), Math.max(to - deleted, 0)],
                value: fromNumberParts(Object.assign(Object.assign({}, toNumberParts(cleanState.value, params)), { prefix,
                    postfix }), params),
            },
            data,
        };
    };
}

/**
 * If minus sign is positioned before prefix,
 * any attempt to erase prefix deletes minus (without deletion of non-removable prefix)
 * @example -$|42 => Backspace => $|42
 */
function createLeadingMinusDeletionPreprocessor(params) {
    return ({ elementState }, inputType) => {
        const { value, selection } = elementState;
        const [from, to] = selection;
        const { prefix, minusSign, negativePattern } = params;
        const beginning = negativePattern === 'prefixFirst' ? prefix : minusSign + prefix;
        const newValue = fromNumberParts(Object.assign(Object.assign({}, toNumberParts(value, params)), { minus: '' }), params);
        const diff = value.length - newValue.length;
        return {
            elementState: inputType.includes('delete') &&
                value.includes(minusSign) &&
                from < beginning.length
                ? {
                    value: newValue,
                    selection: [
                        Math.max(from - diff, beginning.length - 1),
                        Math.max(to - diff, beginning.length - 1),
                    ],
                }
                : elementState,
        };
    };
}

/**
 * It removes repeated leading zeroes for integer part.
 * @example 0,|00005 => Backspace => |5
 * @example -0,|00005 => Backspace => -|5
 * @example User types "000000" => 0|
 * @example 0| => User types "5" => 5|
 */
function createLeadingZeroesValidationPostprocessor(params) {
    const { thousandSeparator } = params;
    const trimLeadingZeroes = (value) => {
        const escapedThousandSeparator = escapeRegExp(thousandSeparator);
        return value
            .replace(
        // all leading zeroes followed by another zero
        new RegExp(`^(\\D+)?[0${escapedThousandSeparator}]+(?=0)`), '$1')
            .replace(
        // zero followed by not-zero digit
        new RegExp(`^(\\D+)?[0${escapedThousandSeparator}]+(?=[1-9])`), '$1');
    };
    const countTrimmedZeroesBefore = (value, index) => {
        const valueBefore = value.slice(0, index);
        const followedByZero = value.slice(index).startsWith('0');
        return (valueBefore.length -
            trimLeadingZeroes(valueBefore).length +
            (followedByZero ? 1 : 0));
    };
    return ({ value, selection }) => {
        const [from, to] = selection;
        const _a = toNumberParts(value, params), { integerPart } = _a, numberParts = __rest(_a, ["integerPart"]);
        const zeroTrimmedIntegerPart = trimLeadingZeroes(integerPart);
        if (integerPart === zeroTrimmedIntegerPart) {
            return { value, selection };
        }
        const newFrom = from - countTrimmedZeroesBefore(value, from);
        const newTo = to - countTrimmedZeroesBefore(value, to);
        return {
            value: fromNumberParts(Object.assign(Object.assign({}, numberParts), { integerPart: zeroTrimmedIntegerPart }), params),
            selection: [Math.max(newFrom, 0), Math.max(newTo, 0)],
        };
    };
}

/**
 * This postprocessor is connected with {@link createMinMaxPlugin}:
 * both validate `min`/`max` bounds of entered value (but at the different point of time).
 */
function createMinMaxPostprocessor({ min, max, decimalSeparator, minusSign, }) {
    return ({ value, selection }) => {
        const parsedNumber = maskitoParseNumber(value, { decimalSeparator, minusSign });
        const limitedValue = 
        /**
         * We cannot limit lower bound if user enters positive number.
         * The same for upper bound and negative number.
         * ___
         * @example (min = 5)
         * Empty input => Without this condition user cannot type 42 (the first digit will be rejected)
         * ___
         * @example (max = -10)
         * Value is -10 => Without this condition user cannot delete 0 to enter another digit
         */
        parsedNumber > 0 ? Math.min(parsedNumber, max) : Math.max(parsedNumber, min);
        if (parsedNumber && limitedValue !== parsedNumber) {
            const newValue = `${limitedValue}`
                .replace('.', decimalSeparator)
                .replace(CHAR_HYPHEN, minusSign);
            return {
                value: newValue,
                selection: [newValue.length, newValue.length],
            };
        }
        return {
            value,
            selection,
        };
    };
}

/**
 * Manage caret-navigation when user "deletes" non-removable digits or separators
 * @example 1,|42 => Backspace => 1|,42 (only if `minimumFractionDigits` is `>0`)
 * @example 1|,42 => Delete => 1,|42 (only if `minimumFractionDigits` is `>0`)
 * @example 0,|00 => Delete => 0,0|0 (only if `minimumFractionDigits` is `>0`)
 * @example 1 |000 => Backspace => 1| 000 (always)
 */
function createNonRemovableCharsDeletionPreprocessor({ decimalSeparator, thousandSeparator, minimumFractionDigits, }) {
    return ({ elementState, data }, actionType) => {
        const { value, selection } = elementState;
        const [from, to] = selection;
        const selectedCharacters = value.slice(from, to);
        const nonRemovableSeparators = minimumFractionDigits
            ? [decimalSeparator, thousandSeparator]
            : [thousandSeparator];
        const areNonRemovableZeroesSelected = Boolean(minimumFractionDigits) &&
            from > value.indexOf(decimalSeparator) &&
            Boolean(selectedCharacters.match(/^0+$/gi));
        if ((actionType !== 'deleteBackward' && actionType !== 'deleteForward') ||
            (!nonRemovableSeparators.includes(selectedCharacters) &&
                !areNonRemovableZeroesSelected)) {
            return {
                elementState,
                data,
            };
        }
        return {
            elementState: {
                value,
                selection: actionType === 'deleteForward' ? [to, to] : [from, from],
            },
            data,
        };
    };
}

/**
 * It pads integer part with zero if user types decimal separator (for empty input).
 * @example Empty input => User types "," (decimal separator) => 0,|
 */
function createNotEmptyIntegerPartPreprocessor(params) {
    const { maximumFractionDigits, decimalSeparator } = params;
    const startWithDecimalSepRegExp = new RegExp(`^\\D*${escapeRegExp(decimalSeparator)}`);
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _a = toNumberParts(value, params), { prefix, postfix } = _a, numberParts = __rest(_a, ["prefix", "postfix"]);
        const onlyNumber = fromNumberParts(numberParts, params);
        const [from, to] = selection;
        const cleanFrom = clamp(from - prefix.length, 0, onlyNumber.length);
        const cleanTo = clamp(to - prefix.length, 0, onlyNumber.length);
        if (maximumFractionDigits <= 0 ||
            onlyNumber.slice(0, cleanFrom).includes(decimalSeparator) ||
            onlyNumber.slice(cleanTo).includes(decimalSeparator) ||
            !data.match(startWithDecimalSepRegExp)) {
            return { elementState, data };
        }
        const digitsBeforeCursor = /\d+/.exec(onlyNumber.slice(0, cleanFrom));
        return {
            elementState,
            data: digitsBeforeCursor ? data : `0${data}`,
        };
    };
}

function createNumberPrefixPostprocessor({ prefix, minusSign, negativePattern, }) {
    return ({ value, selection }, initialElementState) => maskitoPrefixPostprocessorGenerator(value.includes(minusSign) && negativePattern === 'minusFirst'
        ? minusSign + prefix
        : prefix)({ value, selection }, initialElementState);
}

/**
 * It replaces pseudo characters with valid one.
 * @example User types '.' (but separator is equal to comma) => dot is replaced with comma.
 * @example User types hyphen / en-dash / em-dash => it is replaced with minus.
 */
function createPseudoCharactersPreprocessor(_a) {
    var { validCharacter, pseudoCharacters } = _a, params = __rest(_a, ["validCharacter", "pseudoCharacters"]);
    const pseudoCharactersRegExp = new RegExp(`[${pseudoCharacters.join('')}]`, 'gi');
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        const _a = toNumberParts(value, params), { prefix, postfix } = _a, numberParts = __rest(_a, ["prefix", "postfix"]);
        const onlyNumber = fromNumberParts(numberParts, params).replace(pseudoCharactersRegExp, validCharacter);
        return {
            elementState: {
                selection,
                value: fromNumberParts(Object.assign(Object.assign({}, toNumberParts(onlyNumber, params)), { prefix,
                    postfix }), params),
            },
            data: data.replace(pseudoCharactersRegExp, validCharacter),
        };
    };
}

/**
 * It rejects new typed decimal separator if it already exists in text field.
 * Behaviour is similar to native <input type="number"> (Chrome).
 * @example 1|23,45 => Press comma (decimal separator) => 1|23,45 (do nothing).
 */
function createRepeatedDecimalSeparatorPreprocessor(params) {
    const { decimalSeparator } = params;
    if (!decimalSeparator) {
        return identity;
    }
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        const [from, to] = selection;
        return {
            elementState,
            data: !toNumberParts(value, params).decimalSeparator ||
                value.slice(from, to + 1).includes(decimalSeparator)
                ? data
                : data.replaceAll(new RegExp(escapeRegExp(decimalSeparator), 'gi'), ''),
        };
    };
}

/**
 * It adds symbol for separating thousands.
 * @example 1000000 => (thousandSeparator is equal to space) => 1 000 000.
 */
function createThousandSeparatorPostprocessor(params) {
    const { thousandSeparator } = params;
    if (!thousandSeparator) {
        return identity;
    }
    const isAllSpaces = (...chars) => chars.every((x) => /\s/.test(x));
    return ({ value, selection }) => {
        const [initialFrom, initialTo] = selection;
        let [from, to] = selection;
        const { prefix, minus, integerPart, decimalSeparator, decimalPart, postfix } = toNumberParts(value, params);
        const deletedChars = fromNumberParts({ minus, integerPart, decimalSeparator, decimalPart }, params)
            .length -
            (minus +
                integerPart +
                (decimalSeparator ? decimalSeparator + decimalPart : '')).length;
        if (deletedChars > 0 && initialFrom && initialFrom <= deletedChars) {
            from -= deletedChars;
        }
        if (deletedChars > 0 && initialTo && initialTo <= deletedChars) {
            to -= deletedChars;
        }
        const processedIntegerPart = Array.from(integerPart).reduceRight((formattedValuePart, char, i) => {
            const isLeadingThousandSeparator = !i && char === thousandSeparator;
            const isPositionForSeparator = !isLeadingThousandSeparator &&
                Boolean(formattedValuePart.length) &&
                (formattedValuePart.length + 1) % 4 === 0;
            const isSeparator = char === thousandSeparator || isAllSpaces(char, thousandSeparator);
            if (isPositionForSeparator && isSeparator) {
                return thousandSeparator + formattedValuePart;
            }
            if (!isPositionForSeparator && isSeparator) {
                if (from && i <= initialFrom) {
                    from--;
                }
                if (to && i <= initialTo) {
                    to--;
                }
                return formattedValuePart;
            }
            if (!isPositionForSeparator) {
                return char + formattedValuePart;
            }
            if (i < initialFrom) {
                from++;
            }
            if (i < initialTo) {
                to++;
            }
            return char + thousandSeparator + formattedValuePart;
        }, '');
        return {
            value: fromNumberParts({
                prefix,
                minus,
                integerPart: processedIntegerPart,
                decimalSeparator,
                decimalPart,
                postfix,
            }, params),
            selection: [from, to],
        };
    };
}

/**
 * It drops decimal part if `maximumFractionDigits` is zero.
 * @example User pastes '123.45' (but `maximumFractionDigits` is zero) => 123
 */
function createZeroPrecisionPreprocessor(params) {
    const { maximumFractionDigits, decimalSeparator } = params;
    if (maximumFractionDigits > 0 ||
        !decimalSeparator // all separators should be treated only as thousand separators
    ) {
        return identity;
    }
    const decimalPartRegExp = new RegExp(`${escapeRegExp(decimalSeparator)}.*$`, 'g');
    return ({ elementState, data }) => {
        const { value, selection } = elementState;
        const _a = toNumberParts(value, params), { prefix, postfix } = _a, numberParts = __rest(_a, ["prefix", "postfix"]);
        const [from, to] = selection;
        const onlyNumber = fromNumberParts(numberParts, params).replace(decimalPartRegExp, '');
        const newValue = fromNumberParts(Object.assign(Object.assign({}, toNumberParts(onlyNumber, params)), { prefix, postfix }), params);
        return {
            elementState: {
                selection: [
                    Math.min(from, newValue.length),
                    Math.min(to, newValue.length),
                ],
                value: newValue,
            },
            data: data.replace(decimalPartRegExp, ''),
        };
    };
}

const DUMMY_SELECTION = [0, 0];
/**
 * It removes repeated leading zeroes for integer part on blur-event.
 * @example 000000 => blur => 0
 * @example 00005 => blur => 5
 */
function createLeadingZeroesValidationPlugin(params) {
    const dropRepeatedLeadingZeroes = createLeadingZeroesValidationPostprocessor(params);
    return maskitoEventHandler('blur', (element) => {
        const newValue = dropRepeatedLeadingZeroes({
            value: element.value,
            selection: DUMMY_SELECTION,
        }, { value: '', selection: DUMMY_SELECTION }).value;
        maskitoUpdateElement(element, newValue);
    }, { capture: true });
}

/**
 * This plugin is connected with {@link createMinMaxPostprocessor}:
 * both validate `min`/`max` bounds of entered value (but at the different point of time).
 */
function createMinMaxPlugin({ min, max, decimalSeparator, minusSign, }) {
    return maskitoEventHandler('blur', (element, options) => {
        const parsedNumber = maskitoParseNumber(element.value, {
            decimalSeparator,
            minusSign,
        });
        const clampedNumber = clamp(parsedNumber, min, max);
        if (!Number.isNaN(parsedNumber) && parsedNumber !== clampedNumber) {
            maskitoUpdateElement(element, maskitoTransform(stringifyNumberWithoutExp(clampedNumber), options));
        }
    }, { capture: true });
}

/**
 * It pads EMPTY integer part with zero if decimal parts exists.
 * It works on blur event only!
 * @example 1|,23 => Backspace => Blur => 0,23
 */
function createNotEmptyIntegerPlugin(params) {
    const { decimalSeparator } = params;
    if (!decimalSeparator) {
        return noop;
    }
    return maskitoEventHandler('blur', (element) => {
        const _a = toNumberParts(element.value, params), { prefix, postfix } = _a, numberParts = __rest(_a, ["prefix", "postfix"]);
        const onlyNumber = fromNumberParts(numberParts, params).replace(new RegExp(`^(\\D+)?${escapeRegExp(decimalSeparator)}`), `$10${decimalSeparator}`);
        const newValue = fromNumberParts(Object.assign(Object.assign({}, toNumberParts(onlyNumber, params)), { prefix,
            postfix }), params);
        maskitoUpdateElement(element, newValue);
    }, { capture: true });
}

function maskitoNumberOptionsGenerator({ max = Number.MAX_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER, precision = 0, thousandSeparator = CHAR_NO_BREAK_SPACE, decimalSeparator = '.', decimalPseudoSeparators: unsafeDecimalPseudoSeparators, decimalZeroPadding = false, prefix = '', postfix = '', minusSign = CHAR_MINUS, minusPseudoSigns = DEFAULT_PSEUDO_MINUSES.filter((char) => char !== thousandSeparator && char !== decimalSeparator && char !== minusSign), maximumFractionDigits = precision, minimumFractionDigits = decimalZeroPadding ? maximumFractionDigits : 0, negativePattern = 'prefixFirst', } = {}) {
    const decimalPseudoSeparators = validateDecimalPseudoSeparators({
        decimalSeparator,
        thousandSeparator,
        decimalPseudoSeparators: unsafeDecimalPseudoSeparators,
    });
    const params = {
        max,
        min,
        precision,
        thousandSeparator,
        postfix,
        minusSign,
        minusPseudoSigns,
        maximumFractionDigits,
        decimalPseudoSeparators,
        negativePattern,
        decimalZeroPadding,
        decimalSeparator: maximumFractionDigits <= 0 && decimalSeparator === thousandSeparator
            ? ''
            : decimalSeparator,
        prefix: prefix.endsWith(decimalSeparator) && maximumFractionDigits > 0
            ? `${prefix}${CHAR_ZERO_WIDTH_SPACE}`
            : prefix,
        minimumFractionDigits: Math.min(minimumFractionDigits, maximumFractionDigits),
    };
    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: generateMaskExpression(params), preprocessors: [
            createFullWidthToHalfWidthPreprocessor(),
            createInitializationOnlyPreprocessor(params),
            createAffixesFilterPreprocessor(params),
            createPseudoCharactersPreprocessor(Object.assign(Object.assign({}, params), { validCharacter: minusSign, pseudoCharacters: minusPseudoSigns })),
            createPseudoCharactersPreprocessor(Object.assign(Object.assign({}, params), { validCharacter: decimalSeparator, pseudoCharacters: decimalPseudoSeparators })),
            createNotEmptyIntegerPartPreprocessor(params),
            createNonRemovableCharsDeletionPreprocessor(params),
            createZeroPrecisionPreprocessor(params),
            createRepeatedDecimalSeparatorPreprocessor(params),
            createLeadingMinusDeletionPreprocessor(params),
        ], postprocessors: [
            createMinMaxPostprocessor(params),
            createNumberPrefixPostprocessor(params),
            maskitoPostfixPostprocessorGenerator(postfix),
            createThousandSeparatorPostprocessor(params),
            createDecimalZeroPaddingPostprocessor(params),
            emptyPostprocessor(params),
        ], plugins: [
            createLeadingZeroesValidationPlugin(params),
            createNotEmptyIntegerPlugin(params),
            createMinMaxPlugin(params),
        ], overwriteMode: minimumFractionDigits > 0
            ? ({ value, selection: [from] }) => from <= value.indexOf(decimalSeparator) ? 'shift' : 'replace'
            : 'shift' });
}

function maskitoStringifyNumber(number, params) {
    if (Number.isNaN(number) || number === null) {
        return '';
    }
    const { min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER, decimalSeparator = '.', } = params;
    const value = stringifyNumberWithoutExp(clamp(number, min, max)).replace('.', decimalSeparator);
    return maskitoTransform(value, maskitoNumberOptionsGenerator(params));
}

export { maskitoAddOnFocusPlugin, maskitoCaretGuard, maskitoDateOptionsGenerator, maskitoDateRangeOptionsGenerator, maskitoDateTimeOptionsGenerator, maskitoEventHandler, maskitoNumberOptionsGenerator, maskitoParseDate, maskitoParseDateTime, maskitoParseNumber, maskitoParseTime, maskitoPostfixPostprocessorGenerator, maskitoPrefixPostprocessorGenerator, maskitoRejectEvent, maskitoRemoveOnBlurPlugin, maskitoSelectionChangeHandler, maskitoStringifyDate, maskitoStringifyDateTime, maskitoStringifyNumber, maskitoStringifyTime, maskitoTimeOptionsGenerator, maskitoWithPlaceholder };
