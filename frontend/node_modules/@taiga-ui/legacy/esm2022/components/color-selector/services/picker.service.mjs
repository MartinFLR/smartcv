import { DOCUMENT } from '@angular/common';
import { inject, Injectable } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { tuiPreventDefault, tuiTypedFromEvent } from '@taiga-ui/cdk/observables';
import { tuiGetElementPoint, tuiInjectElement } from '@taiga-ui/cdk/utils/dom';
import { map, Observable, startWith, switchMap, takeUntil } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * TODO(v5): delete it
 * @deprecated use new version of {@link https://taiga-ui.dev/components/input-color TuiInputColor} (from @taiga-ui/kit) instead
 */
class TuiPickerService extends Observable {
    constructor() {
        super((subscriber) => this.point$.subscribe(subscriber));
        this.el = tuiInjectElement();
        this.doc = inject(DOCUMENT);
        this.point$ = tuiTypedFromEvent(this.el, 'mousedown').pipe(tuiPreventDefault(), switchMap((event) => {
            const mouseMove$ = tuiTypedFromEvent(this.doc, 'mousemove').pipe(map(({ clientX, clientY }) => tuiGetElementPoint(clientX, clientY, this.el)), takeUntil(tuiTypedFromEvent(this.doc, 'mouseup')));
            return event.target === this.el
                ? mouseMove$.pipe(startWith(tuiGetElementPoint(event.clientX, event.clientY, this.el)))
                : mouseMove$;
        }), takeUntilDestroyed());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiPickerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiPickerService }); }
}
export { TuiPickerService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiPickerService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlja2VyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9sZWdhY3kvY29tcG9uZW50cy9jb2xvci1zZWxlY3Rvci9zZXJ2aWNlcy9waWNrZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDOUQsT0FBTyxFQUFDLGlCQUFpQixFQUFFLGlCQUFpQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDL0UsT0FBTyxFQUFDLGtCQUFrQixFQUFFLGdCQUFnQixFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFFN0UsT0FBTyxFQUFDLEdBQUcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUMsTUFBTSxNQUFNLENBQUM7O0FBRXRFOzs7R0FHRztBQUNILE1BQ2EsZ0JBQWlCLFNBQVEsVUFBb0I7SUF3QnREO1FBQ0ksS0FBSyxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBeEI1QyxPQUFFLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QixRQUFHLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZCLFdBQU0sR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FDbEUsaUJBQWlCLEVBQUUsRUFDbkIsU0FBUyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQzVELEdBQUcsQ0FBQyxDQUFDLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBQyxFQUFFLEVBQUUsQ0FDdkIsa0JBQWtCLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQ2hELEVBQ0QsU0FBUyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FDcEQsQ0FBQztZQUVGLE9BQU8sS0FBSyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsRUFBRTtnQkFDM0IsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQ1gsU0FBUyxDQUNMLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQzVELENBQ0o7Z0JBQ0gsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUNyQixDQUFDLENBQUMsRUFDRixrQkFBa0IsRUFBRSxDQUN2QixDQUFDO0lBSUYsQ0FBQzsrR0ExQlEsZ0JBQWdCO21IQUFoQixnQkFBZ0I7O1NBQWhCLGdCQUFnQjs0RkFBaEIsZ0JBQWdCO2tCQUQ1QixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7aW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7dGFrZVVudGlsRGVzdHJveWVkfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQge3R1aVByZXZlbnREZWZhdWx0LCB0dWlUeXBlZEZyb21FdmVudH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9vYnNlcnZhYmxlcyc7XG5pbXBvcnQge3R1aUdldEVsZW1lbnRQb2ludCwgdHVpSW5qZWN0RWxlbWVudH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9kb20nO1xuaW1wb3J0IHt0eXBlIFR1aVBvaW50fSBmcm9tICdAdGFpZ2EtdWkvY29yZS90eXBlcyc7XG5pbXBvcnQge21hcCwgT2JzZXJ2YWJsZSwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2VVbnRpbH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICogVE9ETyh2NSk6IGRlbGV0ZSBpdFxuICogQGRlcHJlY2F0ZWQgdXNlIG5ldyB2ZXJzaW9uIG9mIHtAbGluayBodHRwczovL3RhaWdhLXVpLmRldi9jb21wb25lbnRzL2lucHV0LWNvbG9yIFR1aUlucHV0Q29sb3J9IChmcm9tIEB0YWlnYS11aS9raXQpIGluc3RlYWRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFR1aVBpY2tlclNlcnZpY2UgZXh0ZW5kcyBPYnNlcnZhYmxlPFR1aVBvaW50PiB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBlbCA9IHR1aUluamVjdEVsZW1lbnQoKTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRvYyA9IGluamVjdChET0NVTUVOVCk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBwb2ludCQgPSB0dWlUeXBlZEZyb21FdmVudCh0aGlzLmVsLCAnbW91c2Vkb3duJykucGlwZShcbiAgICAgICAgdHVpUHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgc3dpdGNoTWFwKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW91c2VNb3ZlJCA9IHR1aVR5cGVkRnJvbUV2ZW50KHRoaXMuZG9jLCAnbW91c2Vtb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHtjbGllbnRYLCBjbGllbnRZfSkgPT5cbiAgICAgICAgICAgICAgICAgICAgdHVpR2V0RWxlbWVudFBvaW50KGNsaWVudFgsIGNsaWVudFksIHRoaXMuZWwpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHR1aVR5cGVkRnJvbUV2ZW50KHRoaXMuZG9jLCAnbW91c2V1cCcpKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQgPT09IHRoaXMuZWxcbiAgICAgICAgICAgICAgICA/IG1vdXNlTW92ZSQucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydFdpdGgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR1aUdldEVsZW1lbnRQb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLCB0aGlzLmVsKSxcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbW91c2VNb3ZlJDtcbiAgICAgICAgfSksXG4gICAgICAgIHRha2VVbnRpbERlc3Ryb3llZCgpLFxuICAgICk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKHN1YnNjcmliZXIpID0+IHRoaXMucG9pbnQkLnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gICAgfVxufVxuIl19