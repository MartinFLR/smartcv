import { inject, Pipe } from '@angular/core';
import { TUI_OBFUSCATE_OPTIONS } from './obfuscate.options';
import * as i0 from "@angular/core";
class TuiObfuscatePipe {
    constructor() {
        this.option = inject(TUI_OBFUSCATE_OPTIONS);
    }
    /**
     * Transforms the input value by obfuscating it according to the specified recipe or symbol.
     *
     * @param value The value to be obfuscated should be a string.
     * @param recipe The name of the recipe to use for obfuscation or a single character symbol for custom obfuscation.
     * @returns The obfuscated string.
     * @throws Will throw an error if the specified recipe is not found.
     */
    transform(value, recipe = '') {
        if (!value) {
            return value;
        }
        if (!recipe) {
            return this.option.default(value);
        }
        const obfuscate = this.option.recipes[recipe];
        if (obfuscate) {
            return obfuscate(value);
        }
        if (recipe.length === 1) {
            return this.option.default(value, recipe[0]);
        }
        const availableRecipes = Object.keys(this.option.recipes).sort();
        throw new Error(`Obfuscate recipe "${recipe}" not found. Available recipes: [${availableRecipes}]`);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiObfuscatePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: TuiObfuscatePipe, isStandalone: true, name: "tuiObfuscate" }); }
}
export { TuiObfuscatePipe };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiObfuscatePipe, decorators: [{
            type: Pipe,
            args: [{
                    standalone: true,
                    name: 'tuiObfuscate',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JmdXNjYXRlLnBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jZGsvcGlwZXMvb2JmdXNjYXRlL29iZnVzY2F0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFxQixNQUFNLGVBQWUsQ0FBQztBQUUvRCxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQzs7QUFFMUQsTUFJYSxnQkFBZ0I7SUFKN0I7UUFLcUIsV0FBTSxHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0tBbUMzRDtJQWpDRzs7Ozs7OztPQU9HO0lBQ0ksU0FBUyxDQUFDLEtBQWEsRUFBRSxNQUFNLEdBQUcsRUFBRTtRQUN2QyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1IsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNyQztRQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTlDLElBQUksU0FBUyxFQUFFO1lBQ1gsT0FBTyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0I7UUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFakUsTUFBTSxJQUFJLEtBQUssQ0FDWCxxQkFBcUIsTUFBTSxvQ0FBb0MsZ0JBQWdCLEdBQUcsQ0FDckYsQ0FBQztJQUNOLENBQUM7K0dBbkNRLGdCQUFnQjs2R0FBaEIsZ0JBQWdCOztTQUFoQixnQkFBZ0I7NEZBQWhCLGdCQUFnQjtrQkFKNUIsSUFBSTttQkFBQztvQkFDRixVQUFVLEVBQUUsSUFBSTtvQkFDaEIsSUFBSSxFQUFFLGNBQWM7aUJBQ3ZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtpbmplY3QsIFBpcGUsIHR5cGUgUGlwZVRyYW5zZm9ybX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7VFVJX09CRlVTQ0FURV9PUFRJT05TfSBmcm9tICcuL29iZnVzY2F0ZS5vcHRpb25zJztcblxuQFBpcGUoe1xuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgbmFtZTogJ3R1aU9iZnVzY2F0ZScsXG59KVxuZXhwb3J0IGNsYXNzIFR1aU9iZnVzY2F0ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbiA9IGluamVjdChUVUlfT0JGVVNDQVRFX09QVElPTlMpO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgdmFsdWUgYnkgb2JmdXNjYXRpbmcgaXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgcmVjaXBlIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgb2JmdXNjYXRlZCBzaG91bGQgYmUgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHJlY2lwZSBUaGUgbmFtZSBvZiB0aGUgcmVjaXBlIHRvIHVzZSBmb3Igb2JmdXNjYXRpb24gb3IgYSBzaW5nbGUgY2hhcmFjdGVyIHN5bWJvbCBmb3IgY3VzdG9tIG9iZnVzY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBvYmZ1c2NhdGVkIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNwZWNpZmllZCByZWNpcGUgaXMgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgcmVjaXBlID0gJycpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlY2lwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uLmRlZmF1bHQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JmdXNjYXRlID0gdGhpcy5vcHRpb24ucmVjaXBlc1tyZWNpcGVdO1xuXG4gICAgICAgIGlmIChvYmZ1c2NhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmZ1c2NhdGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY2lwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbi5kZWZhdWx0KHZhbHVlLCByZWNpcGVbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlUmVjaXBlcyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9uLnJlY2lwZXMpLnNvcnQoKTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgT2JmdXNjYXRlIHJlY2lwZSBcIiR7cmVjaXBlfVwiIG5vdCBmb3VuZC4gQXZhaWxhYmxlIHJlY2lwZXM6IFske2F2YWlsYWJsZVJlY2lwZXN9XWAsXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19