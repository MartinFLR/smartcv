/// <reference types="@taiga-ui/tsconfig/ng-dev-mode" />
import { tuiInRange, tuiNormalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DATE_FILLER_LENGTH } from './date-fillers';
import { MIN_DAY, MONTHS_IN_YEAR } from './date-time';
import { TuiDayOfWeek } from './day-of-week';
import { TuiMonth } from './month';
import { TuiMonthNumber } from './month-number';
import { TuiYear } from './year';
/**
 * Immutable date object, consisting of day, month and year
 */
export class TuiDay extends TuiMonth {
    /**
     * @param year
     * @param month (starting with 0)
     * @param day
     */
    constructor(year, month, day) {
        super(year, month);
        this.day = day;
        ngDevMode && console.assert(TuiDay.isValidDay(year, month, day));
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    static fromLocalNativeDate(date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    static fromUtcNativeDate(date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    }
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    static isValidDay(year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    }
    /**
     * Current day based on local time zone
     */
    static currentLocal() {
        const nativeDate = new Date();
        const year = nativeDate.getFullYear();
        const month = nativeDate.getMonth();
        const day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Returns current day based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        const year = nativeDate.getUTCFullYear();
        const month = nativeDate.getUTCMonth();
        const day = nativeDate.getUTCDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    static normalizeOf(year, month, day) {
        const normalizedYear = TuiYear.normalizeYearPart(year);
        const normalizedMonth = TuiMonth.normalizeMonthPart(month);
        const normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    }
    static lengthBetween(from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    }
    static parseRawDateString(date, dateMode = 'DMY') {
        ngDevMode &&
            console.assert(date.length === DATE_FILLER_LENGTH, '[parseRawDateString]: wrong date string length');
        switch (dateMode) {
            case 'MDY':
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            case 'YMD':
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case 'DMY':
            default:
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    }
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    static normalizeParse(rawDate, dateMode = 'DMY') {
        const { day, month, year } = this.parseRawDateString(rawDate, dateMode);
        return TuiDay.normalizeOf(year, month, day);
    }
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    static jsonParse(yearMonthDayString) {
        const { day, month, year } = this.parseRawDateString(yearMonthDayString, 'YMD');
        if (!TuiMonth.isValidMonth(year, month) ||
            !Number.isInteger(day) ||
            !tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new TuiInvalidDayException(year, month, day);
        }
        return new TuiDay(year, month, day);
    }
    static normalizeDayPart(day, month, year) {
        ngDevMode && console.assert(TuiMonth.isValidMonth(year, month));
        const monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return tuiNormalizeToIntNumber(day, 1, monthDaysCount);
    }
    get formattedDayPart() {
        return String(this.day).padStart(2, '0');
    }
    get isWeekend() {
        const dayOfWeek = this.dayOfWeek(false);
        return dayOfWeek === TuiDayOfWeek.Saturday || dayOfWeek === TuiDayOfWeek.Sunday;
    }
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    dayOfWeek(startFromMonday = true) {
        const dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    }
    /**
     * Passed date is after current
     */
    dayBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    }
    /**
     * Passed date is after or equals to current
     */
    daySameOrBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    }
    /**
     * Passed date is the same as current
     */
    daySame(another) {
        return this.monthSame(another) && this.day === another.day;
    }
    /**
     * Passed date is either before or the same as current
     */
    daySameOrAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    }
    /**
     * Passed date is before current
     */
    dayAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    }
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    dayLimit(min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    }
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @return new date object as a result of offsetting current
     */
    append({ year = 0, month = 0, day = 0 }) {
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        let years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        let months = totalMonths % MONTHS_IN_YEAR;
        const monthDaysCount = TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        const currentMonthDaysCount = TuiMonth.getMonthDaysCount(this.month, TuiYear.isLeapYear(years));
        let days = day;
        if (this.day > monthDaysCount) {
            days += this.day - (currentMonthDaysCount - monthDaysCount);
        }
        else if (currentMonthDaysCount < monthDaysCount &&
            this.day === currentMonthDaysCount) {
            days += this.day + (monthDaysCount - currentMonthDaysCount);
        }
        else {
            days += this.day;
        }
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === TuiMonthNumber.December) {
                years++;
                months = TuiMonthNumber.January;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === TuiMonthNumber.January) {
                years--;
                months = TuiMonthNumber.December;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    }
    /**
     * Returns formatted whole date
     */
    getFormattedDay(dateFormat, separator) {
        ngDevMode &&
            console.assert(separator.length === 1, 'Separator should consist of only 1 symbol');
        const dd = this.formattedDayPart;
        const mm = this.formattedMonthPart;
        const yyyy = this.formattedYear;
        switch (dateFormat) {
            case 'MDY':
                return `${mm}${separator}${dd}${separator}${yyyy}`;
            case 'YMD':
                return `${yyyy}${separator}${mm}${separator}${dd}`;
            case 'DMY':
            default:
                return `${dd}${separator}${mm}${separator}${yyyy}`;
        }
    }
    toString(dateFormat = 'DMY', separator = '.') {
        return this.getFormattedDay(dateFormat, separator);
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedDayPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        const date = super.toLocalNativeDate();
        date.setDate(this.day);
        return date;
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month, this.day));
    }
}
export class TuiInvalidDayException extends Error {
    constructor(year, month, day) {
        super(ngDevMode ? `Invalid day: ${year}-${month}-${day}` : '');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2RhdGUtdGltZS9kYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsd0RBQXdEO0FBRXhELE9BQU8sRUFBQyxVQUFVLEVBQUUsdUJBQXVCLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUU3RSxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBQUMsT0FBTyxFQUFFLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNwRCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDakMsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRTlDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sTUFBTyxTQUFRLFFBQVE7SUFDaEM7Ozs7T0FJRztJQUNILFlBQ0ksSUFBWSxFQUNaLEtBQWEsRUFDRyxHQUFXO1FBRTNCLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFGSCxRQUFHLEdBQUgsR0FBRyxDQUFRO1FBRzNCLFNBQVMsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxJQUFVO1FBQ3hDLE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENB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Q29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkB0YWlnYS11aS90c2NvbmZpZy9uZy1kZXYtbW9kZVwiIC8+XG5cbmltcG9ydCB7dHVpSW5SYW5nZSwgdHVpTm9ybWFsaXplVG9JbnROdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvbWF0aCc7XG5cbmltcG9ydCB7REFURV9GSUxMRVJfTEVOR1RIfSBmcm9tICcuL2RhdGUtZmlsbGVycyc7XG5pbXBvcnQge01JTl9EQVksIE1PTlRIU19JTl9ZRUFSfSBmcm9tICcuL2RhdGUtdGltZSc7XG5pbXBvcnQge1R1aURheU9mV2Vla30gZnJvbSAnLi9kYXktb2Ytd2Vlayc7XG5pbXBvcnQge1R1aU1vbnRofSBmcm9tICcuL21vbnRoJztcbmltcG9ydCB7VHVpTW9udGhOdW1iZXJ9IGZyb20gJy4vbW9udGgtbnVtYmVyJztcbmltcG9ydCB7dHlwZSBUdWlEYXRlTW9kZSwgdHlwZSBUdWlEYXlMaWtlfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7VHVpWWVhcn0gZnJvbSAnLi95ZWFyJztcblxuLyoqXG4gKiBJbW11dGFibGUgZGF0ZSBvYmplY3QsIGNvbnNpc3Rpbmcgb2YgZGF5LCBtb250aCBhbmQgeWVhclxuICovXG5leHBvcnQgY2xhc3MgVHVpRGF5IGV4dGVuZHMgVHVpTW9udGgge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoIChzdGFydGluZyB3aXRoIDApXG4gICAgICogQHBhcmFtIGRheVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB5ZWFyOiBudW1iZXIsXG4gICAgICAgIG1vbnRoOiBudW1iZXIsXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBkYXk6IG51bWJlcixcbiAgICApIHtcbiAgICAgICAgc3VwZXIoeWVhciwgbW9udGgpO1xuICAgICAgICBuZ0Rldk1vZGUgJiYgY29uc29sZS5hc3NlcnQoVHVpRGF5LmlzVmFsaWREYXkoeWVhciwgbW9udGgsIGRheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMge0BsaW5rIFR1aURheX0gZnJvbSBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZnJvbUxvY2FsTmF0aXZlRGF0ZShkYXRlOiBEYXRlKTogVHVpRGF5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHtAbGluayBUdWlEYXl9IGZyb20gbmF0aXZlIHtAbGluayBEYXRlfSB1c2luZyBVVENcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21VdGNOYXRpdmVEYXRlKGRhdGU6IERhdGUpOiBUdWlEYXkge1xuICAgICAgICByZXR1cm4gbmV3IFR1aURheShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkaXR5IG9mIHllYXIsIG1vbnRoIGFuZCBkYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoXG4gICAgICogQHBhcmFtIGRheVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB2YWxpZGl0eVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNWYWxpZERheSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBUdWlNb250aC5pc1ZhbGlkTW9udGgoeWVhciwgbW9udGgpICYmXG4gICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGRheSkgJiZcbiAgICAgICAgICAgIHR1aUluUmFuZ2UoXG4gICAgICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgICAgIE1JTl9EQVksXG4gICAgICAgICAgICAgICAgVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGgsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFyKSkgKyAxLFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGF5IGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgb3ZlcnJpZGUgY3VycmVudExvY2FsKCk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB5ZWFyID0gbmF0aXZlRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBtb250aCA9IG5hdGl2ZURhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgY29uc3QgZGF5ID0gbmF0aXZlRGF0ZS5nZXREYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IGRheSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG92ZXJyaWRlIGN1cnJlbnRVdGMoKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3QgbmF0aXZlRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBuYXRpdmVEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gbmF0aXZlRGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICBjb25zdCBkYXkgPSBuYXRpdmVEYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHtAbGluayBUdWlEYXl9IG5vcm1hbGl6aW5nIHllYXIsIG1vbnRoIGFuZCBkYXkuIHtAbGluayBOYU59IGlzIHR1cm5lZCBpbnRvIG1pbmltYWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhciBhbnkgeWVhciB2YWx1ZSwgaW5jbHVkaW5nIGludmFsaWRcbiAgICAgKiBAcGFyYW0gbW9udGggYW55IG1vbnRoIHZhbHVlLCBpbmNsdWRpbmcgaW52YWxpZCAobW9udGhzIHN0YXJ0IHdpdGggMClcbiAgICAgKiBAcGFyYW0gZGF5IGFueSBkYXkgdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIGRhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG5vcm1hbGl6ZU9mKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWWVhciA9IFR1aVllYXIubm9ybWFsaXplWWVhclBhcnQoeWVhcik7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRNb250aCA9IFR1aU1vbnRoLm5vcm1hbGl6ZU1vbnRoUGFydChtb250aCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREYXkgPSBUdWlEYXkubm9ybWFsaXplRGF5UGFydChcbiAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNb250aCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRZZWFyLFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KG5vcm1hbGl6ZWRZZWFyLCBub3JtYWxpemVkTW9udGgsIG5vcm1hbGl6ZWREYXkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgb3ZlcnJpZGUgbGVuZ3RoQmV0d2Vlbihmcm9tOiBUdWlEYXksIHRvOiBUdWlEYXkpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICh0by50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldFRpbWUoKSAtIGZyb20udG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXRUaW1lKCkpIC9cbiAgICAgICAgICAgICAgICAoMTAwMCAqIDYwICogNjAgKiAyNCksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZVJhd0RhdGVTdHJpbmcoXG4gICAgICAgIGRhdGU6IHN0cmluZyxcbiAgICAgICAgZGF0ZU1vZGU6IFR1aURhdGVNb2RlID0gJ0RNWScsXG4gICAgKToge2RheTogbnVtYmVyOyBtb250aDogbnVtYmVyOyB5ZWFyOiBudW1iZXJ9IHtcbiAgICAgICAgbmdEZXZNb2RlICYmXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgICAgICAgICBkYXRlLmxlbmd0aCA9PT0gREFURV9GSUxMRVJfTEVOR1RILFxuICAgICAgICAgICAgICAgICdbcGFyc2VSYXdEYXRlU3RyaW5nXTogd3JvbmcgZGF0ZSBzdHJpbmcgbGVuZ3RoJyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgc3dpdGNoIChkYXRlTW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnTURZJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXk6IHBhcnNlSW50KGRhdGUuc2xpY2UoMywgNSksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IHBhcnNlSW50KGRhdGUuc2xpY2UoMCwgMiksIDEwKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoNiwgMTApLCAxMCksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FzZSAnWU1EJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXk6IHBhcnNlSW50KGRhdGUuc2xpY2UoOCwgMTApLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDUsIDcpLCAxMCkgLSAxLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludChkYXRlLnNsaWNlKDAsIDQpLCAxMCksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FzZSAnRE1ZJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5OiBwYXJzZUludChkYXRlLnNsaWNlKDAsIDIpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDMsIDUpLCAxMCkgLSAxLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludChkYXRlLnNsaWNlKDYsIDEwKSwgMTApLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBNb3ZlIG1vbnRoIGFuZCB5ZWFyIHJlbGF0ZWQgY29kZSBjb3JyZXNwb25kaW5nIGNsYXNzZXNcbiAgICAvKipcbiAgICAgKiBQYXJzaW5nIGEgc3RyaW5nIHdpdGggZGF0ZSB3aXRoIG5vcm1hbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYXdEYXRlIGRhdGUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRhdGVNb2RlIGRhdGUgZm9ybWF0IG9mIHRoZSBkYXRlIHN0cmluZyAoRE1ZIHwgTURZIHwgWU1EKVxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBub3JtYWxpemVQYXJzZShyYXdEYXRlOiBzdHJpbmcsIGRhdGVNb2RlOiBUdWlEYXRlTW9kZSA9ICdETVknKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qge2RheSwgbW9udGgsIHllYXJ9ID0gdGhpcy5wYXJzZVJhd0RhdGVTdHJpbmcocmF3RGF0ZSwgZGF0ZU1vZGUpO1xuXG4gICAgICAgIHJldHVybiBUdWlEYXkubm9ybWFsaXplT2YoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2luZyBhIGRhdGUgc3RyaW5naWZpZWQgaW4gYSB0b0pTT04gZm9ybWF0XG4gICAgICogQHBhcmFtIHllYXJNb250aERheVN0cmluZyBkYXRlIHN0cmluZyBpbiBmb3JtYXQgb2YgWVlZWS1NTS1ERFxuICAgICAqIEByZXR1cm4gZGF0ZVxuICAgICAqIEB0aHJvd3MgZXhjZXB0aW9ucyBpZiBhbnkgcGFydCBvZiB0aGUgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBqc29uUGFyc2UoeWVhck1vbnRoRGF5U3RyaW5nOiBzdHJpbmcpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCB7ZGF5LCBtb250aCwgeWVhcn0gPSB0aGlzLnBhcnNlUmF3RGF0ZVN0cmluZyh5ZWFyTW9udGhEYXlTdHJpbmcsICdZTUQnKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSB8fFxuICAgICAgICAgICAgIU51bWJlci5pc0ludGVnZXIoZGF5KSB8fFxuICAgICAgICAgICAgIXR1aUluUmFuZ2UoXG4gICAgICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgICAgIE1JTl9EQVksXG4gICAgICAgICAgICAgICAgVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGgsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFyKSkgKyAxLFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUdWlJbnZhbGlkRGF5RXhjZXB0aW9uKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBub3JtYWxpemVEYXlQYXJ0KGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgY29uc29sZS5hc3NlcnQoVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSk7XG5cbiAgICAgICAgY29uc3QgbW9udGhEYXlzQ291bnQgPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChcbiAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgVHVpWWVhci5pc0xlYXBZZWFyKHllYXIpLFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0dWlOb3JtYWxpemVUb0ludE51bWJlcihkYXksIDEsIG1vbnRoRGF5c0NvdW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZvcm1hdHRlZERheVBhcnQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLmRheSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlzV2Vla2VuZCgpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZGF5T2ZXZWVrID0gdGhpcy5kYXlPZldlZWsoZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBkYXlPZldlZWsgPT09IFR1aURheU9mV2Vlay5TYXR1cmRheSB8fCBkYXlPZldlZWsgPT09IFR1aURheU9mV2Vlay5TdW5kYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXkgb2Ygd2Vla1xuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0RnJvbU1vbmRheSB3aGV0aGVyIHdlZWsgc3RhcnRzIGZyb20gTW9uZGF5IGFuZCBub3QgZnJvbSBTdW5kYXlcbiAgICAgKiBAcmV0dXJuIGRheSBvZiB3ZWVrIChmcm9tIDAgdG8gNilcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF5T2ZXZWVrKHN0YXJ0RnJvbU1vbmRheSA9IHRydWUpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkYXlPZldlZWsgPSBzdGFydEZyb21Nb25kYXlcbiAgICAgICAgICAgID8gdGhpcy50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldERheSgpIC0gMVxuICAgICAgICAgICAgOiB0aGlzLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0RGF5KCk7XG5cbiAgICAgICAgcmV0dXJuIGRheU9mV2VlayA8IDAgPyA2IDogZGF5T2ZXZWVrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGFmdGVyIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF5QmVmb3JlKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEJlZm9yZShhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5IDwgYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgYWZ0ZXIgb3IgZXF1YWxzIHRvIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF5U2FtZU9yQmVmb3JlKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEJlZm9yZShhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5IDw9IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF5U2FtZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID09PSBhbm90aGVyLmRheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBlaXRoZXIgYmVmb3JlIG9yIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF5U2FtZU9yQWZ0ZXIoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQWZ0ZXIoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA+PSBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBiZWZvcmUgY3VycmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBkYXlBZnRlcihhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhBZnRlcihhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID4gYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBpbmcgZGF0ZSBiZXR3ZWVuIHR3byBsaW1pdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaW5cbiAgICAgKiBAcGFyYW0gbWF4XG4gICAgICogQHJldHVybiBjbGFtcGVkIGRhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF5TGltaXQobWluOiBUdWlEYXkgfCBudWxsLCBtYXg6IFR1aURheSB8IG51bGwpOiBUdWlEYXkge1xuICAgICAgICBpZiAobWluICE9PSBudWxsICYmIHRoaXMuZGF5QmVmb3JlKG1pbikpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICE9PSBudWxsICYmIHRoaXMuZGF5QWZ0ZXIobWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltbXV0YWJseSBhbHRlcnMgY3VycmVudCBkYXkgYnkgcGFzc2VkIG9mZnNldFxuICAgICAqXG4gICAgICogSWYgcmVzdWx0aW5nIG1vbnRoIGhhcyBtb3JlIGRheXMgdGhhbiBvcmlnaW5hbCBvbmUsIGRhdGUgaXMgcm91bmRlZCB0byB0aGUgbWF4aW11bSBkYXlcbiAgICAgKiBpbiB0aGUgcmVzdWx0aW5nIG1vbnRoLiBPZmZzZXQgb2YgZGF5cyB3aWxsIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHJlc3VsdGVkIHllYXIgYW5kIG1vbnRoXG4gICAgICogdG8gbm90IGludGVyZmVyZSB3aXRoIHBhcmVudCBjbGFzc2VzIG1ldGhvZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIG5ldyBkYXRlIG9iamVjdCBhcyBhIHJlc3VsdCBvZiBvZmZzZXR0aW5nIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgYXBwZW5kKHt5ZWFyID0gMCwgbW9udGggPSAwLCBkYXkgPSAwfTogVHVpRGF5TGlrZSk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IHRvdGFsTW9udGhzID0gKHRoaXMueWVhciArIHllYXIpICogTU9OVEhTX0lOX1lFQVIgKyB0aGlzLm1vbnRoICsgbW9udGg7XG4gICAgICAgIGxldCB5ZWFycyA9IE1hdGguZmxvb3IodG90YWxNb250aHMgLyBNT05USFNfSU5fWUVBUik7XG4gICAgICAgIGxldCBtb250aHMgPSB0b3RhbE1vbnRocyAlIE1PTlRIU19JTl9ZRUFSO1xuXG4gICAgICAgIGNvbnN0IG1vbnRoRGF5c0NvdW50ID0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQoXG4gICAgICAgICAgICBtb250aHMsXG4gICAgICAgICAgICBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjdXJyZW50TW9udGhEYXlzQ291bnQgPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChcbiAgICAgICAgICAgIHRoaXMubW9udGgsXG4gICAgICAgICAgICBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpLFxuICAgICAgICApO1xuICAgICAgICBsZXQgZGF5cyA9IGRheTtcblxuICAgICAgICBpZiAodGhpcy5kYXkgPiBtb250aERheXNDb3VudCkge1xuICAgICAgICAgICAgZGF5cyArPSB0aGlzLmRheSAtIChjdXJyZW50TW9udGhEYXlzQ291bnQgLSBtb250aERheXNDb3VudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBjdXJyZW50TW9udGhEYXlzQ291bnQgPCBtb250aERheXNDb3VudCAmJlxuICAgICAgICAgICAgdGhpcy5kYXkgPT09IGN1cnJlbnRNb250aERheXNDb3VudFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRheXMgKz0gdGhpcy5kYXkgKyAobW9udGhEYXlzQ291bnQgLSBjdXJyZW50TW9udGhEYXlzQ291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF5cyArPSB0aGlzLmRheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChkYXlzID4gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKSkge1xuICAgICAgICAgICAgZGF5cyAtPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpO1xuXG4gICAgICAgICAgICBpZiAobW9udGhzID09PSBUdWlNb250aE51bWJlci5EZWNlbWJlcikge1xuICAgICAgICAgICAgICAgIHllYXJzKys7XG4gICAgICAgICAgICAgICAgbW9udGhzID0gVHVpTW9udGhOdW1iZXIuSmFudWFyeTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoZGF5cyA8IE1JTl9EQVkpIHtcbiAgICAgICAgICAgIGlmIChtb250aHMgPT09IFR1aU1vbnRoTnVtYmVyLkphbnVhcnkpIHtcbiAgICAgICAgICAgICAgICB5ZWFycy0tO1xuICAgICAgICAgICAgICAgIG1vbnRocyA9IFR1aU1vbnRoTnVtYmVyLkRlY2VtYmVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb250aHMtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF5cyArPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmb3JtYXR0ZWQgd2hvbGUgZGF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGUsIHNlcGFyYXRvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbmdEZXZNb2RlICYmXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGVuZ3RoID09PSAxLFxuICAgICAgICAgICAgICAgICdTZXBhcmF0b3Igc2hvdWxkIGNvbnNpc3Qgb2Ygb25seSAxIHN5bWJvbCcsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGRkID0gdGhpcy5mb3JtYXR0ZWREYXlQYXJ0O1xuICAgICAgICBjb25zdCBtbSA9IHRoaXMuZm9ybWF0dGVkTW9udGhQYXJ0O1xuICAgICAgICBjb25zdCB5eXl5ID0gdGhpcy5mb3JtYXR0ZWRZZWFyO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0ZUZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAnTURZJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7bW19JHtzZXBhcmF0b3J9JHtkZH0ke3NlcGFyYXRvcn0ke3l5eXl9YDtcbiAgICAgICAgICAgIGNhc2UgJ1lNRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3l5eXl9JHtzZXBhcmF0b3J9JHttbX0ke3NlcGFyYXRvcn0ke2RkfWA7XG4gICAgICAgICAgICBjYXNlICdETVknOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGR9JHtzZXBhcmF0b3J9JHttbX0ke3NlcGFyYXRvcn0ke3l5eXl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSB0b1N0cmluZyhkYXRlRm9ybWF0OiBUdWlEYXRlTW9kZSA9ICdETVknLCBzZXBhcmF0b3IgPSAnLicpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci50b0pTT04oKX0tJHt0aGlzLmZvcm1hdHRlZERheVBhcnR9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIHRvTG9jYWxOYXRpdmVEYXRlKCk6IERhdGUge1xuICAgICAgICBjb25zdCBkYXRlID0gc3VwZXIudG9Mb2NhbE5hdGl2ZURhdGUoKTtcblxuICAgICAgICBkYXRlLnNldERhdGUodGhpcy5kYXkpO1xuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdG9VdGNOYXRpdmVEYXRlKCk6IERhdGUge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEModGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFR1aUludmFsaWREYXlFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcikge1xuICAgICAgICBzdXBlcihuZ0Rldk1vZGUgPyBgSW52YWxpZCBkYXk6ICR7eWVhcn0tJHttb250aH0tJHtkYXl9YCA6ICcnKTtcbiAgICB9XG59XG4iXX0=