import { __decorate } from "tslib";
import { inject, Pipe } from '@angular/core';
import { ControlContainer, NgControl, } from '@angular/forms';
import { TuiValidationError } from '@taiga-ui/cdk/classes';
import { tuiIsString, tuiPure } from '@taiga-ui/cdk/utils/miscellaneous';
import { TUI_VALIDATION_ERRORS } from '@taiga-ui/kit/tokens';
import { map, Observable, of } from 'rxjs';
import * as i0 from "@angular/core";
const EMPTY_RECORD = {};
function unwrapObservable(content, context) {
    return content.pipe(map((error) => new TuiValidationError(error || '', context)));
}
function defaultError(content, context) {
    return of(new TuiValidationError(content || '', context));
}
class TuiFieldErrorPipe {
    constructor() {
        this.order = [];
        this.parent = inject(NgControl, { skipSelf: true, optional: true });
        this.self = inject(NgControl, { self: true, optional: true });
        this.container = inject(ControlContainer, { optional: true });
        this.validationErrors = inject(TUI_VALIDATION_ERRORS);
        if (this.self && !this.self.valueAccessor) {
            this.self.valueAccessor = this;
        }
    }
    transform(order) {
        this.order = order;
        return this.computedError;
    }
    registerOnChange() { }
    registerOnTouched() { }
    setDisabledState() { }
    writeValue() { }
    get computedError() {
        return (this.invalid && this.touched && this.error) || of(null);
    }
    get error() {
        const { errorId } = this;
        if (!errorId) {
            return null;
        }
        const firstError = this.controlErrors[errorId];
        const errorContent = this.validationErrors[errorId];
        return this.getError(firstError, errorContent);
    }
    get invalid() {
        return !!this.control?.invalid;
    }
    get touched() {
        return !!this.control?.touched;
    }
    get control() {
        return this.self?.control || this.parent?.control || this.container?.control;
    }
    get errorId() {
        return this.getErrorId(this.order, this.controlErrors);
    }
    get controlErrors() {
        return this.control?.errors || EMPTY_RECORD;
    }
    getError(context, content) {
        if (context instanceof TuiValidationError) {
            return of(context);
        }
        if (content === undefined && tuiIsString(context)) {
            return of(new TuiValidationError(context));
        }
        if (content instanceof Observable) {
            return unwrapObservable(content, context);
        }
        if (content instanceof Function) {
            const message = content(context);
            return message instanceof Observable
                ? unwrapObservable(message, context)
                : defaultError(message, context);
        }
        return defaultError(content, context);
    }
    getErrorId(order, controlErrors) {
        const id = order?.find((errorId) => controlErrors[errorId]);
        const [fallback] = Object.keys(controlErrors);
        return id || fallback || '';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiFieldErrorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: TuiFieldErrorPipe, isStandalone: true, name: "tuiFieldError", pure: false }); }
}
__decorate([
    tuiPure
], TuiFieldErrorPipe.prototype, "getError", null);
__decorate([
    tuiPure
], TuiFieldErrorPipe.prototype, "getErrorId", null);
export { TuiFieldErrorPipe };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiFieldErrorPipe, decorators: [{
            type: Pipe,
            args: [{
                    standalone: true,
                    name: 'tuiFieldError',
                    pure: false,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { getError: [], getErrorId: [] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGQtZXJyb3ItcGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2tpdC9waXBlcy9maWVsZC1lcnJvci9maWVsZC1lcnJvci1waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBcUIsTUFBTSxlQUFlLENBQUM7QUFDL0QsT0FBTyxFQUVILGdCQUFnQixFQUVoQixTQUFTLEdBQ1osTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsV0FBVyxFQUFFLE9BQU8sRUFBQyxNQUFNLG1DQUFtQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRTNELE9BQU8sRUFBQyxHQUFHLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBQyxNQUFNLE1BQU0sQ0FBQzs7QUFFekMsTUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBRXhCLFNBQVMsZ0JBQWdCLENBQ3JCLE9BQXdDLEVBQ3hDLE9BQVk7SUFFWixPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLGtCQUFrQixDQUFDLEtBQUssSUFBSSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RGLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FDakIsT0FBNEIsRUFDNUIsT0FBWTtJQUVaLE9BQU8sRUFBRSxDQUFDLElBQUksa0JBQWtCLENBQUMsT0FBTyxJQUFJLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFFRCxNQUthLGlCQUFpQjtJQU8xQjtRQU5RLFVBQUssR0FBc0IsRUFBRSxDQUFDO1FBQ3JCLFdBQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFLEVBQUMs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T0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBRU4sQ0FBQztZQUUxQixPQUFPLE9BQU8sWUFBWSxVQUFVO2dCQUNoQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQztnQkFDcEMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDeEM7UUFFRCxPQUFPLFlBQVksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUdPLFVBQVUsQ0FDZCxLQUF3QixFQUN4QixhQUFzQztRQUV0QyxNQUFNLEVBQUUsR0FBRyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUM1RCxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUU5QyxPQUFPLEVBQUUsSUFBSSxRQUFRLElBQUksRUFBRSxDQUFDO0lBQ2hDLENBQUM7K0dBdkdRLGlCQUFpQjs2R0FBakIsaUJBQWlCOztBQWlFbEI7SUFEUCxPQUFPO2lEQTRCUDtBQUdPO0lBRFAsT0FBTzttREFTUDtTQXZHUSxpQkFBaUI7NEZBQWpCLGlCQUFpQjtrQkFMN0IsSUFBSTttQkFBQztvQkFDRixVQUFVLEVBQUUsSUFBSTtvQkFDaEIsSUFBSSxFQUFFLGVBQWU7b0JBQ3JCLElBQUksRUFBRSxLQUFLO2lCQUNkOzBFQWtFVyxRQUFRLE1BOEJSLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2luamVjdCwgUGlwZSwgdHlwZSBQaXBlVHJhbnNmb3JtfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgdHlwZSBBYnN0cmFjdENvbnRyb2wsXG4gICAgQ29udHJvbENvbnRhaW5lcixcbiAgICB0eXBlIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIE5nQ29udHJvbCxcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtUdWlWYWxpZGF0aW9uRXJyb3J9IGZyb20gJ0B0YWlnYS11aS9jZGsvY2xhc3Nlcyc7XG5pbXBvcnQge3R1aUlzU3RyaW5nLCB0dWlQdXJlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHtUVUlfVkFMSURBVElPTl9FUlJPUlN9IGZyb20gJ0B0YWlnYS11aS9raXQvdG9rZW5zJztcbmltcG9ydCB7dHlwZSBQb2x5bW9ycGhldXNDb250ZW50fSBmcm9tICdAdGFpZ2EtdWkvcG9seW1vcnBoZXVzJztcbmltcG9ydCB7bWFwLCBPYnNlcnZhYmxlLCBvZn0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IEVNUFRZX1JFQ09SRCA9IHt9O1xuXG5mdW5jdGlvbiB1bndyYXBPYnNlcnZhYmxlKFxuICAgIGNvbnRlbnQ6IE9ic2VydmFibGU8UG9seW1vcnBoZXVzQ29udGVudD4sXG4gICAgY29udGV4dDogYW55LFxuKTogT2JzZXJ2YWJsZTxUdWlWYWxpZGF0aW9uRXJyb3I+IHtcbiAgICByZXR1cm4gY29udGVudC5waXBlKG1hcCgoZXJyb3IpID0+IG5ldyBUdWlWYWxpZGF0aW9uRXJyb3IoZXJyb3IgfHwgJycsIGNvbnRleHQpKSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvcihcbiAgICBjb250ZW50OiBQb2x5bW9ycGhldXNDb250ZW50LFxuICAgIGNvbnRleHQ6IGFueSxcbik6IE9ic2VydmFibGU8VHVpVmFsaWRhdGlvbkVycm9yPiB7XG4gICAgcmV0dXJuIG9mKG5ldyBUdWlWYWxpZGF0aW9uRXJyb3IoY29udGVudCB8fCAnJywgY29udGV4dCkpO1xufVxuXG5AUGlwZSh7XG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBuYW1lOiAndHVpRmllbGRFcnJvcicsXG4gICAgcHVyZTogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIFR1aUZpZWxkRXJyb3JQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIHByaXZhdGUgb3JkZXI6IHJlYWRvbmx5IHN0cmluZ1tdID0gW107XG4gICAgcHJpdmF0ZSByZWFkb25seSBwYXJlbnQgPSBpbmplY3QoTmdDb250cm9sLCB7c2tpcFNlbGY6IHRydWUsIG9wdGlvbmFsOiB0cnVlfSk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxmID0gaW5qZWN0KE5nQ29udHJvbCwge3NlbGY6IHRydWUsIG9wdGlvbmFsOiB0cnVlfSk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBjb250YWluZXIgPSBpbmplY3QoQ29udHJvbENvbnRhaW5lciwge29wdGlvbmFsOiB0cnVlfSk7XG4gICAgcHJpdmF0ZSByZWFkb25seSB2YWxpZGF0aW9uRXJyb3JzID0gaW5qZWN0KFRVSV9WQUxJREFUSU9OX0VSUk9SUyk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZiAmJiAhdGhpcy5zZWxmLnZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZi52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0ob3JkZXI6IHJlYWRvbmx5IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxUdWlWYWxpZGF0aW9uRXJyb3IgfCBudWxsPiB7XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZEVycm9yO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWdpc3Rlck9uQ2hhbmdlKCk6IHZvaWQge31cblxuICAgIHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZCgpOiB2b2lkIHt9XG5cbiAgICBwdWJsaWMgc2V0RGlzYWJsZWRTdGF0ZSgpOiB2b2lkIHt9XG5cbiAgICBwdWJsaWMgd3JpdGVWYWx1ZSgpOiB2b2lkIHt9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGNvbXB1dGVkRXJyb3IoKTogT2JzZXJ2YWJsZTxUdWlWYWxpZGF0aW9uRXJyb3IgfCBudWxsPiB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbnZhbGlkICYmIHRoaXMudG91Y2hlZCAmJiB0aGlzLmVycm9yKSB8fCBvZihudWxsKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBlcnJvcigpOiBPYnNlcnZhYmxlPFR1aVZhbGlkYXRpb25FcnJvcj4gfCBudWxsIHtcbiAgICAgICAgY29uc3Qge2Vycm9ySWR9ID0gdGhpcztcblxuICAgICAgICBpZiAoIWVycm9ySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlyc3RFcnJvciA9IHRoaXMuY29udHJvbEVycm9yc1tlcnJvcklkXTtcbiAgICAgICAgY29uc3QgZXJyb3JDb250ZW50ID0gdGhpcy52YWxpZGF0aW9uRXJyb3JzW2Vycm9ySWRdO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEVycm9yKGZpcnN0RXJyb3IsIGVycm9yQ29udGVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgaW52YWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb250cm9sPy5pbnZhbGlkO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IHRvdWNoZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY29udHJvbD8udG91Y2hlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBjb250cm9sKCk6IEFic3RyYWN0Q29udHJvbCB8IG51bGwgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxmPy5jb250cm9sIHx8IHRoaXMucGFyZW50Py5jb250cm9sIHx8IHRoaXMuY29udGFpbmVyPy5jb250cm9sO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IGVycm9ySWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXJyb3JJZCh0aGlzLm9yZGVyLCB0aGlzLmNvbnRyb2xFcnJvcnMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IGNvbnRyb2xFcnJvcnMoKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sPy5lcnJvcnMgfHwgRU1QVFlfUkVDT1JEO1xuICAgIH1cblxuICAgIEB0dWlQdXJlXG4gICAgcHJpdmF0ZSBnZXRFcnJvcihcbiAgICAgICAgY29udGV4dDogYW55LFxuICAgICAgICBjb250ZW50PzogT2JzZXJ2YWJsZTxQb2x5bW9ycGhldXNDb250ZW50PiB8IFBvbHltb3JwaGV1c0NvbnRlbnQsXG4gICAgKTogT2JzZXJ2YWJsZTxUdWlWYWxpZGF0aW9uRXJyb3I+IHtcbiAgICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBUdWlWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBvZihjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZW50ID09PSB1bmRlZmluZWQgJiYgdHVpSXNTdHJpbmcoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvZihuZXcgVHVpVmFsaWRhdGlvbkVycm9yKGNvbnRleHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcE9ic2VydmFibGUoY29udGVudCwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY29udGVudChjb250ZXh0KSBhc1xuICAgICAgICAgICAgICAgIHwgT2JzZXJ2YWJsZTxQb2x5bW9ycGhldXNDb250ZW50PlxuICAgICAgICAgICAgICAgIHwgUG9seW1vcnBoZXVzQ29udGVudDtcblxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UgaW5zdGFuY2VvZiBPYnNlcnZhYmxlXG4gICAgICAgICAgICAgICAgPyB1bndyYXBPYnNlcnZhYmxlKG1lc3NhZ2UsIGNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0RXJyb3IobWVzc2FnZSwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdEVycm9yKGNvbnRlbnQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIEB0dWlQdXJlXG4gICAgcHJpdmF0ZSBnZXRFcnJvcklkKFxuICAgICAgICBvcmRlcjogcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgICAgIGNvbnRyb2xFcnJvcnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGlkID0gb3JkZXI/LmZpbmQoKGVycm9ySWQpID0+IGNvbnRyb2xFcnJvcnNbZXJyb3JJZF0pO1xuICAgICAgICBjb25zdCBbZmFsbGJhY2tdID0gT2JqZWN0LmtleXMoY29udHJvbEVycm9ycyk7XG5cbiAgICAgICAgcmV0dXJuIGlkIHx8IGZhbGxiYWNrIHx8ICcnO1xuICAgIH1cbn1cbiJdfQ==