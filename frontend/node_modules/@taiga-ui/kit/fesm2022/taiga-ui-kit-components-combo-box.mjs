import * as i0 from '@angular/core';
import { inject, signal, isSignal, computed, effect, untracked, Directive, Input } from '@angular/core';
import { TuiControl, tuiAsControl } from '@taiga-ui/cdk/classes';
import { TUI_STRICT_MATCHER, TUI_ALLOW_SIGNAL_WRITES } from '@taiga-ui/cdk/constants';
import { tuiAsOptionContent } from '@taiga-ui/core/components/data-list';
import * as i1 from '@taiga-ui/core/components/textfield';
import { TuiTextfieldComponent, TuiTextfieldDirective, tuiInjectAuxiliary, tuiAsTextfieldAccessor, TuiWithTextfield } from '@taiga-ui/core/components/textfield';
import { tuiDropdownOpen, tuiDropdownEnabled, TuiDropdownDirective } from '@taiga-ui/core/directives/dropdown';
import { TUI_ITEMS_HANDLERS } from '@taiga-ui/core/directives/items-handlers';
import { TuiSelectOption } from '@taiga-ui/kit/components/select';

class TuiComboBox extends TuiControl {
    constructor() {
        super(...arguments);
        this.host = inject(TuiTextfieldComponent);
        this.textfield = inject(TuiTextfieldDirective);
        this.open = tuiDropdownOpen();
        this.dropdownEnabled = tuiDropdownEnabled(this.interactive);
        this.dropdown = inject(TuiDropdownDirective);
        this.handlers = inject(TUI_ITEMS_HANDLERS);
        this.matcher = signal(TUI_STRICT_MATCHER);
        this.strict = signal(true);
        this.datalist = tuiInjectAuxiliary((x) => x !== this && 'options' in x && isSignal(x.options));
        this.options = computed(() => this.datalist()
            ?.options?.() // TODO(v5): remove optional call `?.()`
            .filter((x) => !this.handlers.disabledItemHandler()(x)) ?? []);
        this.nonStrictControlEffect = effect(() => {
            if (!this.options().length &&
                !this.strict() &&
                this.stringify(this.value()) !== this.textfield.value()) {
                this.onChange(this.textfield.value() || null);
            }
        }, TUI_ALLOW_SIGNAL_WRITES);
        this.matchingEffect = effect(() => {
            const options = this.options();
            const matcher = this.matcher();
            if (!options.length || !matcher) {
                return;
            }
            const textfieldValue = this.textfield.value();
            const selectedOption = options.find((x) => matcher(x, textfieldValue, this.handlers.stringify()));
            const value = untracked(() => this.value());
            const unchanged = this.stringify(value) === textfieldValue;
            const fallback = this.strict() || !textfieldValue ? null : textfieldValue;
            this.onChange(selectedOption ??
                /**
                 * Don't clear already not-null form control value on new `this.options()` array.
                 * Otherwise, `ComboBox` becomes incompatible with virtual scroll
                 * (which displays large lists of elements by only rendering the items that fit on-screen).
                 * Users can still able to patch form value with `null` on new items if they wish the such behavior.
                 */
                (unchanged ? value : fallback));
        }, TUI_ALLOW_SIGNAL_WRITES);
        this.newValueEffect = effect(() => {
            const stringified = this.stringify(this.value());
            this.textfield.value.update((x) => stringified || x);
        }, TUI_ALLOW_SIGNAL_WRITES);
        this.blurEffect = effect(() => {
            const incomplete = untracked(() => this.strict() && this.value() === null);
            if (!this.host.focused() && incomplete) {
                this.textfield.value.set('');
            }
        }, TUI_ALLOW_SIGNAL_WRITES);
    }
    // TODO(v5): use signal input
    set strictSetter(x) {
        this.strict.set(x);
    }
    // TODO(v5): use signal input
    set matcherSetter(x) {
        this.matcher.set(x);
    }
    setValue(value) {
        this.textfield.setValue(value);
        this.onChange(value);
        if (!value) {
            this.toggleDropdown(true);
        }
    }
    writeValue(value) {
        const reset = this.control.pristine && this.control.untouched && !value;
        const changed = untracked(() => value !== this.value());
        if (changed || reset) {
            super.writeValue(value);
            untracked(() => this.textfield.value.set(this.stringify(value)));
        }
    }
    toggleDropdown(open = !this.open()) {
        if (this.dropdownEnabled() && this.dropdown._content()) {
            this.open.set(open);
        }
    }
    keydownEnter(event) {
        if (!this.open()) {
            return;
        }
        event.preventDefault();
        const options = this.options();
        if (options.length === 1 && options[0]) {
            this.setValue(options[0]);
            this.toggleDropdown(false);
        }
    }
    stringify(value) {
        return value != null ? this.handlers.stringify()(value) : '';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiComboBox, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: TuiComboBox, isStandalone: true, selector: "input[tuiComboBox]", inputs: { strictSetter: ["strict", "strictSetter"], matcherSetter: ["matcher", "matcherSetter"] }, host: { listeners: { "click": "toggleDropdown()", "input": "toggleDropdown(true)", "keydown.enter": "keydownEnter($event)" }, properties: { "disabled": "disabled()" } }, providers: [
            tuiAsOptionContent(TuiSelectOption),
            tuiAsTextfieldAccessor(TuiComboBox),
            tuiAsControl(TuiComboBox),
        ], usesInheritance: true, hostDirectives: [{ directive: i1.TuiWithTextfield }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiComboBox, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: 'input[tuiComboBox]',
                    providers: [
                        tuiAsOptionContent(TuiSelectOption),
                        tuiAsTextfieldAccessor(TuiComboBox),
                        tuiAsControl(TuiComboBox),
                    ],
                    hostDirectives: [TuiWithTextfield],
                    host: {
                        '[disabled]': 'disabled()',
                        '(click)': 'toggleDropdown()',
                        '(input)': 'toggleDropdown(true)',
                        '(keydown.enter)': 'keydownEnter($event)',
                    },
                }]
        }], propDecorators: { strictSetter: [{
                type: Input,
                args: ['strict']
            }], matcherSetter: [{
                type: Input,
                args: ['matcher']
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { TuiComboBox };
//# sourceMappingURL=taiga-ui-kit-components-combo-box.mjs.map
